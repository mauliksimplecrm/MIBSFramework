// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7 (swiftlang-5.7.0.127.4 clang-1400.0.29.50)
// swift-module-flags: -target arm64-apple-ios15.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name MIBSFramework
// swift-module-flags-ignorable: -enable-bare-slash-regex
import AVFoundation
import AVKit
import Accelerate
import Combine
import CoreGraphics
import CoreImage
import CoreMedia
import CoreText
import CoreVideo
import Dispatch
import Foundation
import JitsiMeetSDK
@_exported import MIBSFramework
import MLKitFaceDetection
import MLKitVision
import MobileCoreServices
import ObjectiveC
import Photos
import QuartzCore
import SafariServices
import Swift
import SystemConfiguration
import UIKit
import UniformTypeIdentifiers
import Vision
import _Concurrency
import _StringProcessing
public let AF: MIBSFramework.Session
public protocol CaretPositioner {
  func getCaretOffset(for text: Swift.String) -> Swift.Int
}
@objc final public class CompatibleAnimationKeypath : ObjectiveC.NSObject {
  @objc public init(keypath: Swift.String)
  @objc public init(keys: [Swift.String])
  final public let animationKeypath: MIBSFramework.AnimationKeypath
  @objc deinit
}
@available(iOSApplicationExtension, unavailable)
@objc extension UIKit.UIScrollView {
  @objc @_Concurrency.MainActor(unsafe) dynamic public var shouldIgnoreScrollingAdjustment: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public var shouldIgnoreContentInsetAdjustment: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public var shouldRestoreScrollViewContentOffset: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
}
public enum PopoverOption {
  case arrowSize(CoreFoundation.CGSize)
  case animationIn(Foundation.TimeInterval)
  case animationOut(Foundation.TimeInterval)
  case cornerRadius(CoreFoundation.CGFloat)
  case sideEdge(CoreFoundation.CGFloat)
  case blackOverlayColor(UIKit.UIColor)
  case overlayBlur(UIKit.UIBlurEffect.Style)
  case type(MIBSFramework.PopoverType)
  case color(UIKit.UIColor)
  case dismissOnBlackOverlayTap(Swift.Bool)
  case showBlackOverlay(Swift.Bool)
  case springDamping(CoreFoundation.CGFloat)
  case initialSpringVelocity(CoreFoundation.CGFloat)
  case sideOffset(CoreFoundation.CGFloat)
  case borderColor(UIKit.UIColor)
}
@objc public enum PopoverType : Swift.Int {
  case up
  case down
  case left
  case right
  case auto
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc @objcMembers @_Concurrency.MainActor(unsafe) open class Popover : UIKit.UIView {
  @objc @_Concurrency.MainActor(unsafe) open var arrowSize: CoreFoundation.CGSize
  @objc @_Concurrency.MainActor(unsafe) open var animationIn: Swift.Double
  @objc @_Concurrency.MainActor(unsafe) open var animationOut: Swift.Double
  @objc @_Concurrency.MainActor(unsafe) open var cornerRadiusP: CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor(unsafe) open var sideEdge: CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor(unsafe) open var popoverType: MIBSFramework.PopoverType
  @objc @_Concurrency.MainActor(unsafe) open var blackOverlayColor: UIKit.UIColor
  @objc @_Concurrency.MainActor(unsafe) open var overlayBlur: UIKit.UIBlurEffect?
  @objc @_Concurrency.MainActor(unsafe) open var popoverColor: UIKit.UIColor
  @objc @_Concurrency.MainActor(unsafe) open var dismissOnBlackOverlayTap: Swift.Bool
  @objc @_Concurrency.MainActor(unsafe) open var showBlackOverlay: Swift.Bool
  @objc @_Concurrency.MainActor(unsafe) open var highlightFromView: Swift.Bool
  @objc @_Concurrency.MainActor(unsafe) open var highlightCornerRadius: CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor(unsafe) open var springDamping: CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor(unsafe) open var initialSpringVelocity: CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor(unsafe) open var sideOffset: CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor(unsafe) open var borderColorP: UIKit.UIColor?
  @objc @_Concurrency.MainActor(unsafe) open var willShowHandler: (() -> ())?
  @objc @_Concurrency.MainActor(unsafe) open var willDismissHandler: (() -> ())?
  @objc @_Concurrency.MainActor(unsafe) open var didShowHandler: (() -> ())?
  @objc @_Concurrency.MainActor(unsafe) open var didDismissHandler: (() -> ())?
  @objc @_Concurrency.MainActor(unsafe) public var blackOverlay: UIKit.UIControl {
    get
  }
  @_Concurrency.MainActor(unsafe) @objc dynamic public init()
  @objc @_Concurrency.MainActor(unsafe) public init(showHandler: (() -> ())?, dismissHandler: (() -> ())?)
  @_Concurrency.MainActor(unsafe) public init(options: [MIBSFramework.PopoverOption]?, showHandler: (() -> ())? = nil, dismissHandler: (() -> ())? = nil)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func layoutSubviews()
  @objc @_Concurrency.MainActor(unsafe) open func showAsDialog(_ contentView: UIKit.UIView)
  @objc @_Concurrency.MainActor(unsafe) open func showAsDialog(_ contentView: UIKit.UIView, inView: UIKit.UIView)
  @objc @_Concurrency.MainActor(unsafe) open func show(_ contentView: UIKit.UIView, fromView: UIKit.UIView)
  @objc @_Concurrency.MainActor(unsafe) open func show(_ contentView: UIKit.UIView, fromView: UIKit.UIView, inView: UIKit.UIView)
  @objc @_Concurrency.MainActor(unsafe) open func show(_ contentView: UIKit.UIView, point: CoreFoundation.CGPoint)
  @objc @_Concurrency.MainActor(unsafe) open func show(_ contentView: UIKit.UIView, point: CoreFoundation.CGPoint, inView: UIKit.UIView)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func accessibilityPerformEscape() -> Swift.Bool
  @objc @_Concurrency.MainActor(unsafe) open func dismiss()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func draw(_ rect: CoreFoundation.CGRect)
  @objc deinit
}
public enum SwiftyJSONError : Swift.Int, Swift.Error {
  case unsupportedType
  case indexOutOfBounds
  case elementTooDeep
  case wrongType
  case notExist
  case invalidJSON
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension MIBSFramework.SwiftyJSONError : Foundation.CustomNSError {
  public static var errorDomain: Swift.String {
    get
  }
  public var errorCode: Swift.Int {
    get
  }
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
public enum Type : Swift.Int {
  case number
  case string
  case bool
  case array
  case dictionary
  case null
  case unknown
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct JSON {
  public init(data: Foundation.Data, options opt: Foundation.JSONSerialization.ReadingOptions = []) throws
  public init(_ object: Any)
  public init(parseJSON jsonString: Swift.String)
  public mutating func merge(with other: MIBSFramework.JSON) throws
  public func merged(with other: MIBSFramework.JSON) throws -> MIBSFramework.JSON
  public var type: MIBSFramework.`Type` {
    get
  }
  public var error: MIBSFramework.SwiftyJSONError? {
    get
  }
  public var object: Any {
    get
    set
  }
  @available(*, unavailable, renamed: "null")
  public static var nullJSON: MIBSFramework.JSON {
    get
  }
  public static var null: MIBSFramework.JSON {
    get
  }
}
public enum Index<T> : Swift.Comparable {
  case array(Swift.Int)
  case dictionary(Swift.DictionaryIndex<Swift.String, T>)
  case null
  public static func == (lhs: MIBSFramework.Index<T>, rhs: MIBSFramework.Index<T>) -> Swift.Bool
  public static func < (lhs: MIBSFramework.Index<T>, rhs: MIBSFramework.Index<T>) -> Swift.Bool
}
public typealias JSONIndex = MIBSFramework.Index<MIBSFramework.JSON>
public typealias JSONRawIndex = MIBSFramework.Index<Any>
extension MIBSFramework.JSON : Swift.Collection {
  public typealias Index = MIBSFramework.JSONRawIndex
  public var startIndex: MIBSFramework.JSON.Index {
    get
  }
  public var endIndex: MIBSFramework.JSON.Index {
    get
  }
  public func index(after i: MIBSFramework.JSON.Index) -> MIBSFramework.JSON.Index
  public subscript(position: MIBSFramework.JSON.Index) -> (Swift.String, MIBSFramework.JSON) {
    get
  }
  public typealias Element = (Swift.String, MIBSFramework.JSON)
  public typealias Indices = Swift.DefaultIndices<MIBSFramework.JSON>
  public typealias Iterator = Swift.IndexingIterator<MIBSFramework.JSON>
  public typealias SubSequence = Swift.Slice<MIBSFramework.JSON>
}
public enum JSONKey {
  case index(Swift.Int)
  case key(Swift.String)
}
public protocol JSONSubscriptType {
  var jsonKey: MIBSFramework.JSONKey { get }
}
extension Swift.Int : MIBSFramework.JSONSubscriptType {
  public var jsonKey: MIBSFramework.JSONKey {
    get
  }
}
extension Swift.String : MIBSFramework.JSONSubscriptType {
  public var jsonKey: MIBSFramework.JSONKey {
    get
  }
}
extension MIBSFramework.JSON {
  public subscript(path: [MIBSFramework.JSONSubscriptType]) -> MIBSFramework.JSON {
    get
    set
  }
  public subscript(path: MIBSFramework.JSONSubscriptType...) -> MIBSFramework.JSON {
    get
    set
  }
}
extension MIBSFramework.JSON : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.StringLiteralType)
  public init(extendedGraphemeClusterLiteral value: Swift.StringLiteralType)
  public init(unicodeScalarLiteral value: Swift.StringLiteralType)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StringLiteralType
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.StringLiteralType
}
extension MIBSFramework.JSON : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.IntegerLiteralType)
  public typealias IntegerLiteralType = Swift.IntegerLiteralType
}
extension MIBSFramework.JSON : Swift.ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Swift.BooleanLiteralType)
  public typealias BooleanLiteralType = Swift.BooleanLiteralType
}
extension MIBSFramework.JSON : Swift.ExpressibleByFloatLiteral {
  public init(floatLiteral value: Swift.FloatLiteralType)
  public typealias FloatLiteralType = Swift.FloatLiteralType
}
extension MIBSFramework.JSON : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Swift.String, Any)...)
  public typealias Key = Swift.String
  public typealias Value = Any
}
extension MIBSFramework.JSON : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: Any...)
  public typealias ArrayLiteralElement = Any
}
extension MIBSFramework.JSON : Swift.RawRepresentable {
  public init?(rawValue: Any)
  public var rawValue: Any {
    get
  }
  public func rawData(options opt: Foundation.JSONSerialization.WritingOptions = JSONSerialization.WritingOptions(rawValue: 0)) throws -> Foundation.Data
  public func rawString(_ encoding: Swift.String.Encoding = .utf8, options opt: Foundation.JSONSerialization.WritingOptions = .prettyPrinted) -> Swift.String?
  public func rawString(_ options: [MIBSFramework.writingOptionsKeys : Any]) -> Swift.String?
  public typealias RawValue = Any
}
extension MIBSFramework.JSON : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension MIBSFramework.JSON {
  public var array: [MIBSFramework.JSON]? {
    get
  }
  public var arrayValue: [MIBSFramework.JSON] {
    get
  }
  public var arrayObject: [Any]? {
    get
    set
  }
}
extension MIBSFramework.JSON {
  public var dictionary: [Swift.String : MIBSFramework.JSON]? {
    get
  }
  public var dictionaryValue: [Swift.String : MIBSFramework.JSON] {
    get
  }
  public var dictionaryObject: [Swift.String : Any]? {
    get
    set
  }
}
extension MIBSFramework.JSON {
  public var bool: Swift.Bool? {
    get
    set
  }
  public var boolValue: Swift.Bool {
    get
    set
  }
}
extension MIBSFramework.JSON {
  public var string: Swift.String? {
    get
    set
  }
  public var stringValue: Swift.String {
    get
    set
  }
}
extension MIBSFramework.JSON {
  public var number: Foundation.NSNumber? {
    get
    set
  }
  public var numberValue: Foundation.NSNumber {
    get
    set
  }
}
extension MIBSFramework.JSON {
  public var null: Foundation.NSNull? {
    get
    set
  }
  public func exists() -> Swift.Bool
}
extension MIBSFramework.JSON {
  public var url: Foundation.URL? {
    get
    set
  }
}
extension MIBSFramework.JSON {
  public var double: Swift.Double? {
    get
    set
  }
  public var doubleValue: Swift.Double {
    get
    set
  }
  public var float: Swift.Float? {
    get
    set
  }
  public var floatValue: Swift.Float {
    get
    set
  }
  public var int: Swift.Int? {
    get
    set
  }
  public var intValue: Swift.Int {
    get
    set
  }
  public var uInt: Swift.UInt? {
    get
    set
  }
  public var uIntValue: Swift.UInt {
    get
    set
  }
  public var int8: Swift.Int8? {
    get
    set
  }
  public var int8Value: Swift.Int8 {
    get
    set
  }
  public var uInt8: Swift.UInt8? {
    get
    set
  }
  public var uInt8Value: Swift.UInt8 {
    get
    set
  }
  public var int16: Swift.Int16? {
    get
    set
  }
  public var int16Value: Swift.Int16 {
    get
    set
  }
  public var uInt16: Swift.UInt16? {
    get
    set
  }
  public var uInt16Value: Swift.UInt16 {
    get
    set
  }
  public var int32: Swift.Int32? {
    get
    set
  }
  public var int32Value: Swift.Int32 {
    get
    set
  }
  public var uInt32: Swift.UInt32? {
    get
    set
  }
  public var uInt32Value: Swift.UInt32 {
    get
    set
  }
  public var int64: Swift.Int64? {
    get
    set
  }
  public var int64Value: Swift.Int64 {
    get
    set
  }
  public var uInt64: Swift.UInt64? {
    get
    set
  }
  public var uInt64Value: Swift.UInt64 {
    get
    set
  }
}
extension MIBSFramework.JSON : Swift.Comparable {
}
public func == (lhs: MIBSFramework.JSON, rhs: MIBSFramework.JSON) -> Swift.Bool
public func <= (lhs: MIBSFramework.JSON, rhs: MIBSFramework.JSON) -> Swift.Bool
public func >= (lhs: MIBSFramework.JSON, rhs: MIBSFramework.JSON) -> Swift.Bool
public func > (lhs: MIBSFramework.JSON, rhs: MIBSFramework.JSON) -> Swift.Bool
public func < (lhs: MIBSFramework.JSON, rhs: MIBSFramework.JSON) -> Swift.Bool
public enum writingOptionsKeys {
  case jsonSerialization
  case castNilToNSNull
  case maxObjextDepth
  case encoding
  public static func == (a: MIBSFramework.writingOptionsKeys, b: MIBSFramework.writingOptionsKeys) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension MIBSFramework.JSON : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@objc @_Concurrency.MainActor(unsafe) open class IQBarButtonItem : UIKit.UIBarButtonItem {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var tintColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) open func setTarget(_ target: Swift.AnyObject?, action: ObjectiveC.Selector?)
  @objc @_Concurrency.MainActor(unsafe) open var invocation: MIBSFramework.IQInvocation?
  @objc deinit
}
public func <- <T>(left: inout T, right: MIBSFramework.Map) where T : Swift.SignedInteger
public func <- <T>(left: inout T?, right: MIBSFramework.Map) where T : Swift.SignedInteger
public func <- <T>(left: inout T, right: MIBSFramework.Map) where T : Swift.UnsignedInteger
public func <- <T>(left: inout T?, right: MIBSFramework.Map) where T : Swift.UnsignedInteger
public protocol InfoLabelDelegate : AnyObject {
  func infoLabel(_ infoLabel: MIBSFramework.InfoLabel, didExpand expanded: Swift.Bool)
}
@objc @_Concurrency.MainActor(unsafe) open class InfoLabel : UIKit.UILabel {
  @_Concurrency.MainActor(unsafe) open var numberOfVisibleLines: Swift.Int
  @_Concurrency.MainActor(unsafe) weak open var delegate: MIBSFramework.InfoLabelDelegate?
  @_Concurrency.MainActor(unsafe) public init(text: Swift.String, expanded: Swift.Bool = false)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
extension MIBSFramework.InfoLabel {
  @objc @_Concurrency.MainActor(unsafe) dynamic public func configureLayout()
}
public protocol Interpolatable : MIBSFramework.AnyInterpolatable {
  func interpolate(to: Self, amount: CoreFoundation.CGFloat) -> Self
}
public protocol SpatialInterpolatable : MIBSFramework.AnyInterpolatable {
  func interpolate(to: Self, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> Self
}
public protocol AnyInterpolatable {
  func _interpolate(to: Self, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> Self
}
extension MIBSFramework.Interpolatable {
  public func _interpolate(to: Self, amount: CoreFoundation.CGFloat, spatialOutTangent _: CoreFoundation.CGPoint?, spatialInTangent _: CoreFoundation.CGPoint?) -> Self
}
extension MIBSFramework.SpatialInterpolatable {
  public func interpolate(to: Self, amount: CoreFoundation.CGFloat) -> Self
  public func _interpolate(to: Self, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> Self
}
extension Swift.Double : MIBSFramework.Interpolatable {
}
extension CoreFoundation.CGFloat : MIBSFramework.Interpolatable {
}
extension Swift.Float : MIBSFramework.Interpolatable {
}
extension MIBSFramework.Interpolatable where Self : Swift.BinaryFloatingPoint {
  public func interpolate(to: Self, amount: CoreFoundation.CGFloat) -> Self
}
extension CoreFoundation.CGRect : MIBSFramework.Interpolatable {
  public func interpolate(to: CoreFoundation.CGRect, amount: CoreFoundation.CGFloat) -> CoreFoundation.CGRect
}
extension CoreFoundation.CGSize : MIBSFramework.Interpolatable {
  public func interpolate(to: CoreFoundation.CGSize, amount: CoreFoundation.CGFloat) -> CoreFoundation.CGSize
}
extension CoreFoundation.CGPoint : MIBSFramework.SpatialInterpolatable {
  public func interpolate(to: CoreFoundation.CGPoint, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> CoreFoundation.CGPoint
}
extension MIBSFramework.Color : MIBSFramework.Interpolatable {
  public func interpolate(to: MIBSFramework.Color, amount: CoreFoundation.CGFloat) -> MIBSFramework.Color
}
extension MIBSFramework.Vector1D : MIBSFramework.Interpolatable {
  public func interpolate(to: MIBSFramework.Vector1D, amount: CoreFoundation.CGFloat) -> MIBSFramework.Vector1D
}
extension MIBSFramework.Vector2D : MIBSFramework.SpatialInterpolatable {
  public func interpolate(to: MIBSFramework.Vector2D, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> MIBSFramework.Vector2D
}
extension MIBSFramework.Vector3D : MIBSFramework.SpatialInterpolatable {
  public func interpolate(to: MIBSFramework.Vector3D, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> MIBSFramework.Vector3D
}
extension Swift.Array : MIBSFramework.Interpolatable, MIBSFramework.AnyInterpolatable where Element : MIBSFramework.Interpolatable {
  public func interpolate(to: [Element], amount: CoreFoundation.CGFloat) -> [Element]
}
public protocol TextUnformatter {
  func unformat(_ formattedText: Swift.String?) -> Swift.String?
}
open class SumTextInputFormatter : MIBSFramework.TextInputFormatter, MIBSFramework.TextFormatter, MIBSFramework.TextUnformatter, MIBSFramework.TextNumberFormatter, MIBSFramework.TextNumberUnformatter, MIBSFramework.CaretPositioner {
  open var maximumIntegerCharacters: Swift.Int {
    get
    set
  }
  open var maximumDecimalCharacters: Swift.Int {
    get
  }
  open var prefix: Swift.String? {
    get
  }
  open var suffix: Swift.String? {
    get
  }
  open var groupingSeparator: Swift.String {
    get
  }
  open var decimalSeparator: Swift.String {
    get
  }
  open var groupingSize: Swift.Int {
    get
  }
  open var numberFormatter: Foundation.NumberFormatter {
    get
  }
  public init(numberFormatter: Foundation.NumberFormatter)
  public init(textPattern: Swift.String, patternSymbol: Swift.Character = "#")
  open func formatInput(currentText: Swift.String, range: Foundation.NSRange, replacementString text: Swift.String) -> MIBSFramework.FormattedTextValue
  open func format(_ unformatted: Swift.String?) -> Swift.String?
  open func format(_ number: Foundation.NSNumber) -> Swift.String?
  open func unformat(_ formattedText: Swift.String?) -> Swift.String?
  open func unformatNumber(_ formattedText: Swift.String?) -> Foundation.NSNumber?
  open func getCaretOffset(for text: Swift.String) -> Swift.Int
  @objc deinit
}
extension MIBSFramework.Animation {
  public typealias DownloadClosure = (MIBSFramework.Animation?) -> Swift.Void
  final public var duration: Foundation.TimeInterval {
    get
  }
  final public var bounds: CoreFoundation.CGRect {
    get
  }
  final public var size: CoreFoundation.CGSize {
    get
  }
  public static func named(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, animationCache: MIBSFramework.AnimationCacheProvider? = nil) -> MIBSFramework.Animation?
  public static func filepath(_ filepath: Swift.String, animationCache: MIBSFramework.AnimationCacheProvider? = nil) -> MIBSFramework.Animation?
  public static func asset(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, animationCache: MIBSFramework.AnimationCacheProvider? = nil) -> MIBSFramework.Animation?
  public static func from(data: Foundation.Data, strategy: MIBSFramework.DecodingStrategy = LottieConfiguration.shared.decodingStrategy) throws -> MIBSFramework.Animation
  public static func loadedFrom(url: Foundation.URL, session: Foundation.URLSession = .shared, closure: @escaping MIBSFramework.Animation.DownloadClosure, animationCache: MIBSFramework.AnimationCacheProvider?)
  final public func progressTime(forMarker named: Swift.String) -> MIBSFramework.AnimationProgressTime?
  final public func frameTime(forMarker named: Swift.String) -> MIBSFramework.AnimationFrameTime?
  final public func durationFrameTime(forMarker named: Swift.String) -> MIBSFramework.AnimationFrameTime?
  final public func progressTime(forFrame frameTime: MIBSFramework.AnimationFrameTime, clamped: Swift.Bool = true) -> MIBSFramework.AnimationProgressTime
  final public func frameTime(forProgress progressTime: MIBSFramework.AnimationProgressTime) -> MIBSFramework.AnimationFrameTime
  final public func time(forFrame frameTime: MIBSFramework.AnimationFrameTime) -> Foundation.TimeInterval
  final public func frameTime(forTime time: Foundation.TimeInterval) -> MIBSFramework.AnimationFrameTime
}
@available(iOSApplicationExtension, unavailable)
extension MIBSFramework.IQKeyboardManager {
  @objc final public func reloadInputViews()
}
@available(iOSApplicationExtension, unavailable)
extension MIBSFramework.IQKeyboardManager {
  @objc final public var canGoPrevious: Swift.Bool {
    @objc get
  }
  @objc final public var canGoNext: Swift.Bool {
    @objc get
  }
  @discardableResult
  @objc final public func goPrevious() -> Swift.Bool
  @discardableResult
  @objc final public func goNext() -> Swift.Bool
}
public enum LottieBackgroundBehavior {
  case stop
  case pause
  case pauseAndRestore
  case forceFinish
  case continuePlaying
  public static func `default`(for renderingEngine: MIBSFramework.RenderingEngine) -> MIBSFramework.LottieBackgroundBehavior
  public static func == (a: MIBSFramework.LottieBackgroundBehavior, b: MIBSFramework.LottieBackgroundBehavior) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum LottieLoopMode {
  case playOnce
  case loop
  case autoReverse
  case `repeat`(Swift.Float)
  case repeatBackwards(Swift.Float)
}
extension MIBSFramework.LottieLoopMode : Swift.Equatable {
  public static func == (lhs: MIBSFramework.LottieLoopMode, rhs: MIBSFramework.LottieLoopMode) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers @IBDesignable @_Concurrency.MainActor(unsafe) final public class AnimationView : MIBSFramework.AnimationViewBase {
  @_Concurrency.MainActor(unsafe) public init(animation: MIBSFramework.Animation?, imageProvider: MIBSFramework.AnimationImageProvider? = nil, textProvider: MIBSFramework.AnimationTextProvider = DefaultTextProvider(), fontProvider: MIBSFramework.AnimationFontProvider = DefaultFontProvider(), configuration: MIBSFramework.LottieConfiguration = .shared, logger: MIBSFramework.LottieLogger = .shared)
  @_Concurrency.MainActor(unsafe) public init(configuration: MIBSFramework.LottieConfiguration = .shared, logger: MIBSFramework.LottieLogger = .shared)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) final public let configuration: MIBSFramework.LottieConfiguration
  @_Concurrency.MainActor(unsafe) final public var valueProviders: [MIBSFramework.AnimationKeypath : MIBSFramework.AnyValueProvider] {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var backgroundBehavior: MIBSFramework.LottieBackgroundBehavior {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var animation: MIBSFramework.Animation? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var imageProvider: MIBSFramework.AnimationImageProvider {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var textProvider: MIBSFramework.AnimationTextProvider {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var fontProvider: MIBSFramework.AnimationFontProvider {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var isAnimationPlaying: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var isAnimationQueued: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var loopMode: MIBSFramework.LottieLoopMode {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var shouldRasterizeWhenIdle: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var currentProgress: MIBSFramework.AnimationProgressTime {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var currentTime: Foundation.TimeInterval {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var currentFrame: MIBSFramework.AnimationFrameTime {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var realtimeAnimationFrame: MIBSFramework.AnimationFrameTime {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var realtimeAnimationProgress: MIBSFramework.AnimationProgressTime {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var animationSpeed: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var respectAnimationFrameRate: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var viewportFrame: CoreFoundation.CGRect? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override final public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) final public var currentRenderingEngine: MIBSFramework.RenderingEngine? {
    get
  }
  @_Concurrency.MainActor(unsafe) final public func play(completion: MIBSFramework.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor(unsafe) final public func play(fromProgress: MIBSFramework.AnimationProgressTime? = nil, toProgress: MIBSFramework.AnimationProgressTime, loopMode: MIBSFramework.LottieLoopMode? = nil, completion: MIBSFramework.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor(unsafe) final public func play(fromFrame: MIBSFramework.AnimationFrameTime? = nil, toFrame: MIBSFramework.AnimationFrameTime, loopMode: MIBSFramework.LottieLoopMode? = nil, completion: MIBSFramework.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor(unsafe) final public func play(fromMarker: Swift.String? = nil, toMarker: Swift.String, loopMode: MIBSFramework.LottieLoopMode? = nil, completion: MIBSFramework.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor(unsafe) final public func play(marker: Swift.String, loopMode: MIBSFramework.LottieLoopMode? = nil, completion: MIBSFramework.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor(unsafe) final public func stop()
  @_Concurrency.MainActor(unsafe) final public func pause()
  @_Concurrency.MainActor(unsafe) final public func reloadImages()
  @_Concurrency.MainActor(unsafe) final public func forceDisplayUpdate()
  @_Concurrency.MainActor(unsafe) final public func setValueProvider(_ valueProvider: MIBSFramework.AnyValueProvider, keypath: MIBSFramework.AnimationKeypath)
  @_Concurrency.MainActor(unsafe) final public func getValue(for keypath: MIBSFramework.AnimationKeypath, atFrame: MIBSFramework.AnimationFrameTime?) -> Any?
  @_Concurrency.MainActor(unsafe) final public func getOriginalValue(for keypath: MIBSFramework.AnimationKeypath, atFrame: MIBSFramework.AnimationFrameTime?) -> Any?
  @_Concurrency.MainActor(unsafe) final public func logHierarchyKeypaths()
  @_Concurrency.MainActor(unsafe) final public func addSubview(_ subview: MIBSFramework.AnimationSubview, forLayerAt keypath: MIBSFramework.AnimationKeypath)
  @_Concurrency.MainActor(unsafe) final public func convert(_ rect: CoreFoundation.CGRect, toLayerAt keypath: MIBSFramework.AnimationKeypath?) -> CoreFoundation.CGRect?
  @_Concurrency.MainActor(unsafe) final public func convert(_ point: CoreFoundation.CGPoint, toLayerAt keypath: MIBSFramework.AnimationKeypath?) -> CoreFoundation.CGPoint?
  @_Concurrency.MainActor(unsafe) final public func setNodeIsEnabled(isEnabled: Swift.Bool, keypath: MIBSFramework.AnimationKeypath)
  @_Concurrency.MainActor(unsafe) final public func progressTime(forMarker named: Swift.String) -> MIBSFramework.AnimationProgressTime?
  @_Concurrency.MainActor(unsafe) final public func frameTime(forMarker named: Swift.String) -> MIBSFramework.AnimationFrameTime?
  @_Concurrency.MainActor(unsafe) final public func durationFrameTime(forMarker named: Swift.String) -> MIBSFramework.AnimationFrameTime?
  @objc deinit
}
public typealias AFResult<Success> = Swift.Result<Success, MIBSFramework.AFError>
extension UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public func makeToast(_ message: Swift.String?, duration: Foundation.TimeInterval = ToastManager.shared.duration, position: MIBSFramework.ToastPosition = ToastManager.shared.position, title: Swift.String? = nil, image: UIKit.UIImage? = nil, style: MIBSFramework.ToastStyle = ToastManager.shared.style, completion: ((_ didTap: Swift.Bool) -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) public func makeToast(_ message: Swift.String?, duration: Foundation.TimeInterval = ToastManager.shared.duration, point: CoreFoundation.CGPoint, title: Swift.String?, image: UIKit.UIImage?, style: MIBSFramework.ToastStyle = ToastManager.shared.style, completion: ((_ didTap: Swift.Bool) -> Swift.Void)?)
  @_Concurrency.MainActor(unsafe) public func showToast(_ toast: UIKit.UIView, duration: Foundation.TimeInterval = ToastManager.shared.duration, position: MIBSFramework.ToastPosition = ToastManager.shared.position, completion: ((_ didTap: Swift.Bool) -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) public func showToast(_ toast: UIKit.UIView, duration: Foundation.TimeInterval = ToastManager.shared.duration, point: CoreFoundation.CGPoint, completion: ((_ didTap: Swift.Bool) -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) public func hideToast()
  @_Concurrency.MainActor(unsafe) public func hideToast(_ toast: UIKit.UIView)
  @_Concurrency.MainActor(unsafe) public func hideAllToasts(includeActivity: Swift.Bool = false, clearQueue: Swift.Bool = true)
  @_Concurrency.MainActor(unsafe) public func clearToastQueue()
  @_Concurrency.MainActor(unsafe) public func makeToastActivity(_ position: MIBSFramework.ToastPosition)
  @_Concurrency.MainActor(unsafe) public func makeToastActivity(_ point: CoreFoundation.CGPoint)
  @_Concurrency.MainActor(unsafe) public func hideToastActivity()
  @_Concurrency.MainActor(unsafe) public func toastViewForMessage(_ message: Swift.String?, title: Swift.String?, image: UIKit.UIImage?, style: MIBSFramework.ToastStyle) throws -> UIKit.UIView
}
public struct ToastStyle {
  public init()
  public var backgroundColor: UIKit.UIColor
  public var titleColor: UIKit.UIColor
  public var messageColor: UIKit.UIColor
  public var maxWidthPercentage: CoreFoundation.CGFloat {
    get
    set
  }
  public var maxHeightPercentage: CoreFoundation.CGFloat {
    get
    set
  }
  public var horizontalPadding: CoreFoundation.CGFloat
  public var verticalPadding: CoreFoundation.CGFloat
  public var cornerRadius: CoreFoundation.CGFloat
  public var titleFont: UIKit.UIFont
  public var messageFont: UIKit.UIFont
  public var titleAlignment: UIKit.NSTextAlignment
  public var messageAlignment: UIKit.NSTextAlignment
  public var titleNumberOfLines: Swift.Int
  public var messageNumberOfLines: Swift.Int
  public var displayShadow: Swift.Bool
  public var shadowColor: UIKit.UIColor
  public var shadowOpacity: Swift.Float {
    get
    set
  }
  public var shadowRadius: CoreFoundation.CGFloat
  public var shadowOffset: CoreFoundation.CGSize
  public var imageSize: CoreFoundation.CGSize
  public var activitySize: CoreFoundation.CGSize
  public var fadeDuration: Swift.Double
  public var activityIndicatorColor: UIKit.UIColor
  public var activityBackgroundColor: UIKit.UIColor
}
@_hasMissingDesignatedInitializers public class ToastManager {
  public static let shared: MIBSFramework.ToastManager
  public var style: MIBSFramework.ToastStyle
  public var isTapToDismissEnabled: Swift.Bool
  public var isQueueEnabled: Swift.Bool
  public var duration: Swift.Double
  public var position: MIBSFramework.ToastPosition
  @objc deinit
}
public enum ToastPosition {
  case top
  case center
  case bottom
  public static func == (a: MIBSFramework.ToastPosition, b: MIBSFramework.ToastPosition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
infix operator +| : DefaultPrecedence
infix operator +- : DefaultPrecedence
open class RetryPolicy : MIBSFramework.RequestInterceptor {
  public static let defaultRetryLimit: Swift.UInt
  public static let defaultExponentialBackoffBase: Swift.UInt
  public static let defaultExponentialBackoffScale: Swift.Double
  public static let defaultRetryableHTTPMethods: Swift.Set<MIBSFramework.HTTPMethod>
  public static let defaultRetryableHTTPStatusCodes: Swift.Set<Swift.Int>
  public static let defaultRetryableURLErrorCodes: Swift.Set<Foundation.URLError.Code>
  final public let retryLimit: Swift.UInt
  final public let exponentialBackoffBase: Swift.UInt
  final public let exponentialBackoffScale: Swift.Double
  final public let retryableHTTPMethods: Swift.Set<MIBSFramework.HTTPMethod>
  final public let retryableHTTPStatusCodes: Swift.Set<Swift.Int>
  final public let retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code>
  public init(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<MIBSFramework.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods, retryableHTTPStatusCodes: Swift.Set<Swift.Int> = RetryPolicy.defaultRetryableHTTPStatusCodes, retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code> = RetryPolicy.defaultRetryableURLErrorCodes)
  open func retry(_ request: MIBSFramework.Request, for session: MIBSFramework.Session, dueTo error: Swift.Error, completion: @escaping (MIBSFramework.RetryResult) -> Swift.Void)
  open func shouldRetry(request: MIBSFramework.Request, dueTo error: Swift.Error) -> Swift.Bool
  @objc deinit
}
extension MIBSFramework.RequestInterceptor where Self == MIBSFramework.RetryPolicy {
  public static var retryPolicy: MIBSFramework.RetryPolicy {
    get
  }
  public static func retryPolicy(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<MIBSFramework.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods, retryableHTTPStatusCodes: Swift.Set<Swift.Int> = RetryPolicy.defaultRetryableHTTPStatusCodes, retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code> = RetryPolicy.defaultRetryableURLErrorCodes) -> MIBSFramework.RetryPolicy
}
open class ConnectionLostRetryPolicy : MIBSFramework.RetryPolicy {
  public init(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<MIBSFramework.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods)
  @objc deinit
}
extension MIBSFramework.RequestInterceptor where Self == MIBSFramework.ConnectionLostRetryPolicy {
  public static var connectionLostRetryPolicy: MIBSFramework.ConnectionLostRetryPolicy {
    get
  }
  public static func connectionLostRetryPolicy(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<MIBSFramework.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods) -> MIBSFramework.ConnectionLostRetryPolicy
}
public struct RequestAdapterState {
  public let requestID: Foundation.UUID
  public let session: MIBSFramework.Session
}
public protocol RequestAdapter {
  func adapt(_ urlRequest: Foundation.URLRequest, for session: MIBSFramework.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  func adapt(_ urlRequest: Foundation.URLRequest, using state: MIBSFramework.RequestAdapterState, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
}
extension MIBSFramework.RequestAdapter {
  public func adapt(_ urlRequest: Foundation.URLRequest, using state: MIBSFramework.RequestAdapterState, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
}
public enum RetryResult {
  case retry
  case retryWithDelay(Foundation.TimeInterval)
  case doNotRetry
  case doNotRetryWithError(Swift.Error)
}
public protocol RequestRetrier {
  func retry(_ request: MIBSFramework.Request, for session: MIBSFramework.Session, dueTo error: Swift.Error, completion: @escaping (MIBSFramework.RetryResult) -> Swift.Void)
}
public protocol RequestInterceptor : MIBSFramework.RequestAdapter, MIBSFramework.RequestRetrier {
}
extension MIBSFramework.RequestInterceptor {
  public func adapt(_ urlRequest: Foundation.URLRequest, for session: MIBSFramework.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  public func retry(_ request: MIBSFramework.Request, for session: MIBSFramework.Session, dueTo error: Swift.Error, completion: @escaping (MIBSFramework.RetryResult) -> Swift.Void)
}
public typealias AdaptHandler = (Foundation.URLRequest, MIBSFramework.Session, _ completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void) -> Swift.Void
public typealias RetryHandler = (MIBSFramework.Request, MIBSFramework.Session, Swift.Error, _ completion: @escaping (MIBSFramework.RetryResult) -> Swift.Void) -> Swift.Void
open class Adapter : MIBSFramework.RequestInterceptor {
  public init(_ adaptHandler: @escaping MIBSFramework.AdaptHandler)
  open func adapt(_ urlRequest: Foundation.URLRequest, for session: MIBSFramework.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  open func adapt(_ urlRequest: Foundation.URLRequest, using state: MIBSFramework.RequestAdapterState, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  @objc deinit
}
extension MIBSFramework.RequestAdapter where Self == MIBSFramework.Adapter {
  public static func adapter(using closure: @escaping MIBSFramework.AdaptHandler) -> MIBSFramework.Adapter
}
open class Retrier : MIBSFramework.RequestInterceptor {
  public init(_ retryHandler: @escaping MIBSFramework.RetryHandler)
  open func retry(_ request: MIBSFramework.Request, for session: MIBSFramework.Session, dueTo error: Swift.Error, completion: @escaping (MIBSFramework.RetryResult) -> Swift.Void)
  @objc deinit
}
extension MIBSFramework.RequestRetrier where Self == MIBSFramework.Retrier {
  public static func retrier(using closure: @escaping MIBSFramework.RetryHandler) -> MIBSFramework.Retrier
}
open class Interceptor : MIBSFramework.RequestInterceptor {
  final public let adapters: [MIBSFramework.RequestAdapter]
  final public let retriers: [MIBSFramework.RequestRetrier]
  public init(adaptHandler: @escaping MIBSFramework.AdaptHandler, retryHandler: @escaping MIBSFramework.RetryHandler)
  public init(adapter: MIBSFramework.RequestAdapter, retrier: MIBSFramework.RequestRetrier)
  public init(adapters: [MIBSFramework.RequestAdapter] = [], retriers: [MIBSFramework.RequestRetrier] = [], interceptors: [MIBSFramework.RequestInterceptor] = [])
  open func adapt(_ urlRequest: Foundation.URLRequest, for session: MIBSFramework.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  open func adapt(_ urlRequest: Foundation.URLRequest, using state: MIBSFramework.RequestAdapterState, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  open func retry(_ request: MIBSFramework.Request, for session: MIBSFramework.Session, dueTo error: Swift.Error, completion: @escaping (MIBSFramework.RetryResult) -> Swift.Void)
  @objc deinit
}
extension MIBSFramework.RequestInterceptor where Self == MIBSFramework.Interceptor {
  public static func interceptor(adapter: @escaping MIBSFramework.AdaptHandler, retrier: @escaping MIBSFramework.RetryHandler) -> MIBSFramework.Interceptor
  public static func interceptor(adapter: MIBSFramework.RequestAdapter, retrier: MIBSFramework.RequestRetrier) -> MIBSFramework.Interceptor
  public static func interceptor(adapters: [MIBSFramework.RequestAdapter] = [], retriers: [MIBSFramework.RequestRetrier] = [], interceptors: [MIBSFramework.RequestInterceptor] = []) -> MIBSFramework.Interceptor
}
open class DefaultTextInputFormatter : MIBSFramework.TextInputFormatter, MIBSFramework.TextFormatter, MIBSFramework.TextUnformatter {
  public init(textPattern: Swift.String, patternSymbol: Swift.Character = "#")
  open func formatInput(currentText: Swift.String, range: Foundation.NSRange, replacementString text: Swift.String) -> MIBSFramework.FormattedTextValue
  open func format(_ unformattedText: Swift.String?) -> Swift.String?
  open func unformat(_ formatted: Swift.String?) -> Swift.String?
  @objc deinit
}
public protocol AnimationTextProvider : AnyObject {
  func textFor(keypathName: Swift.String, sourceText: Swift.String) -> Swift.String
}
final public class DictionaryTextProvider : MIBSFramework.AnimationTextProvider {
  public init(_ values: [Swift.String : Swift.String])
  final public func textFor(keypathName: Swift.String, sourceText: Swift.String) -> Swift.String
  @objc deinit
}
final public class DefaultTextProvider : MIBSFramework.AnimationTextProvider {
  public init()
  final public func textFor(keypathName _: Swift.String, sourceText: Swift.String) -> Swift.String
  @objc deinit
}
public class BundleImageProvider : MIBSFramework.AnimationImageProvider {
  public init(bundle: Foundation.Bundle, searchPath: Swift.String?)
  public func imageForAsset(asset: MIBSFramework.ImageAsset) -> CoreGraphics.CGImage?
  @objc deinit
}
final public class Keyframe<T> {
  public init(_ value: T, spatialInTangent: MIBSFramework.Vector3D? = nil, spatialOutTangent: MIBSFramework.Vector3D? = nil)
  public init(value: T, time: MIBSFramework.AnimationFrameTime, isHold: Swift.Bool = false, inTangent: MIBSFramework.Vector2D? = nil, outTangent: MIBSFramework.Vector2D? = nil, spatialInTangent: MIBSFramework.Vector3D? = nil, spatialOutTangent: MIBSFramework.Vector3D? = nil)
  final public let value: T
  final public let time: MIBSFramework.AnimationFrameTime
  final public let isHold: Swift.Bool
  final public let inTangent: MIBSFramework.Vector2D?
  final public let outTangent: MIBSFramework.Vector2D?
  final public let spatialInTangent: MIBSFramework.Vector3D?
  final public let spatialOutTangent: MIBSFramework.Vector3D?
  @objc deinit
}
extension MIBSFramework.Keyframe : Swift.Equatable where T : Swift.Equatable {
  public static func == (lhs: MIBSFramework.Keyframe<T>, rhs: MIBSFramework.Keyframe<T>) -> Swift.Bool
}
extension MIBSFramework.Keyframe : Swift.Hashable where T : Swift.Hashable {
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class TextFieldStartInputController : ObjectiveC.NSObject, UIKit.UITextFieldDelegate {
  @_Concurrency.MainActor(unsafe) open var formatter: (MIBSFramework.CaretPositioner & MIBSFramework.TextInputFormatter)?
  @_Concurrency.MainActor(unsafe) @objc open func textField(_ textField: UIKit.UITextField, shouldChangeCharactersIn range: Foundation.NSRange, replacementString string: Swift.String) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc open func textFieldDidBeginEditing(_ textField: UIKit.UITextField)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @IBDesignable @_Concurrency.MainActor(unsafe) public class ReadMoreTextView : UIKit.UITextView {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect, textContainer: UIKit.NSTextContainer?)
  @_Concurrency.MainActor(unsafe) @objc convenience dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc convenience dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) public var onSizeChange: (MIBSFramework.ReadMoreTextView) -> ()
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var maximumNumberOfLines: Swift.Int {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var readMoreText: Swift.String? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) public var attributedReadMoreText: Foundation.NSAttributedString? {
    get
    set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var readLessText: Swift.String? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) public var attributedReadLessText: Foundation.NSAttributedString? {
    get
    set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var shouldTrim: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) public func setNeedsUpdateTrim()
  @_Concurrency.MainActor(unsafe) public var readMoreTextPadding: UIKit.UIEdgeInsets
  @_Concurrency.MainActor(unsafe) public var readLessTextPadding: UIKit.UIEdgeInsets
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var text: Swift.String! {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var attributedText: Foundation.NSAttributedString! {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func hitTest(_ point: CoreFoundation.CGPoint, with event: UIKit.UIEvent?) -> UIKit.UIView?
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @objc deinit
}
public protocol TextNumberUnformatter {
  func unformatNumber(_ formattedText: Swift.String?) -> Foundation.NSNumber?
}
@_hasMissingDesignatedInitializers public class Request {
  public enum State {
    case initialized
    case resumed
    case suspended
    case cancelled
    case finished
    public static func == (a: MIBSFramework.Request.State, b: MIBSFramework.Request.State) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let id: Foundation.UUID
  final public let underlyingQueue: Dispatch.DispatchQueue
  final public let serializationQueue: Dispatch.DispatchQueue
  final public let eventMonitor: MIBSFramework.EventMonitor?
  final public let interceptor: MIBSFramework.RequestInterceptor?
  weak public var delegate: MIBSFramework.RequestDelegate? {
    get
  }
  public var state: MIBSFramework.Request.State {
    get
  }
  public var isInitialized: Swift.Bool {
    get
  }
  public var isResumed: Swift.Bool {
    get
  }
  public var isSuspended: Swift.Bool {
    get
  }
  public var isCancelled: Swift.Bool {
    get
  }
  public var isFinished: Swift.Bool {
    get
  }
  public typealias ProgressHandler = (Foundation.Progress) -> Swift.Void
  final public let uploadProgress: Foundation.Progress
  final public let downloadProgress: Foundation.Progress
  public var redirectHandler: MIBSFramework.RedirectHandler? {
    get
  }
  public var cachedResponseHandler: MIBSFramework.CachedResponseHandler? {
    get
  }
  public var credential: Foundation.URLCredential? {
    get
  }
  public var requests: [Foundation.URLRequest] {
    get
  }
  public var firstRequest: Foundation.URLRequest? {
    get
  }
  public var lastRequest: Foundation.URLRequest? {
    get
  }
  public var request: Foundation.URLRequest? {
    get
  }
  public var performedRequests: [Foundation.URLRequest] {
    get
  }
  public var response: Foundation.HTTPURLResponse? {
    get
  }
  public var tasks: [Foundation.URLSessionTask] {
    get
  }
  public var firstTask: Foundation.URLSessionTask? {
    get
  }
  public var lastTask: Foundation.URLSessionTask? {
    get
  }
  public var task: Foundation.URLSessionTask? {
    get
  }
  public var allMetrics: [Foundation.URLSessionTaskMetrics] {
    get
  }
  public var firstMetrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  public var lastMetrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  public var metrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  public var retryCount: Swift.Int {
    get
  }
  public var error: MIBSFramework.AFError? {
    get
  }
  @discardableResult
  public func cancel() -> Self
  @discardableResult
  public func suspend() -> Self
  @discardableResult
  public func resume() -> Self
  @discardableResult
  public func authenticate(username: Swift.String, password: Swift.String, persistence: Foundation.URLCredential.Persistence = .forSession) -> Self
  @discardableResult
  public func authenticate(with credential: Foundation.URLCredential) -> Self
  @discardableResult
  public func downloadProgress(queue: Dispatch.DispatchQueue = .main, closure: @escaping MIBSFramework.Request.ProgressHandler) -> Self
  @discardableResult
  public func uploadProgress(queue: Dispatch.DispatchQueue = .main, closure: @escaping MIBSFramework.Request.ProgressHandler) -> Self
  @discardableResult
  public func redirect(using handler: MIBSFramework.RedirectHandler) -> Self
  @discardableResult
  public func cacheResponse(using handler: MIBSFramework.CachedResponseHandler) -> Self
  @discardableResult
  public func cURLDescription(on queue: Dispatch.DispatchQueue, calling handler: @escaping (Swift.String) -> Swift.Void) -> Self
  @discardableResult
  public func cURLDescription(calling handler: @escaping (Swift.String) -> Swift.Void) -> Self
  @discardableResult
  public func onURLRequestCreation(on queue: Dispatch.DispatchQueue = .main, perform handler: @escaping (Foundation.URLRequest) -> Swift.Void) -> Self
  @discardableResult
  public func onURLSessionTaskCreation(on queue: Dispatch.DispatchQueue = .main, perform handler: @escaping (Foundation.URLSessionTask) -> Swift.Void) -> Self
  @objc deinit
}
extension MIBSFramework.Request : Swift.Equatable {
  public static func == (lhs: MIBSFramework.Request, rhs: MIBSFramework.Request) -> Swift.Bool
}
extension MIBSFramework.Request : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension MIBSFramework.Request : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension MIBSFramework.Request {
  public func cURLDescription() -> Swift.String
}
public protocol RequestDelegate : AnyObject {
  var sessionConfiguration: Foundation.URLSessionConfiguration { get }
  var startImmediately: Swift.Bool { get }
  func cleanup(after request: MIBSFramework.Request)
  func retryResult(for request: MIBSFramework.Request, dueTo error: MIBSFramework.AFError, completion: @escaping (MIBSFramework.RetryResult) -> Swift.Void)
  func retryRequest(_ request: MIBSFramework.Request, withDelay timeDelay: Foundation.TimeInterval?)
}
@_hasMissingDesignatedInitializers public class DataRequest : MIBSFramework.Request {
  final public let convertible: MIBSFramework.URLRequestConvertible
  public var data: Foundation.Data? {
    get
  }
  @discardableResult
  public func validate(_ validation: @escaping MIBSFramework.DataRequest.Validation) -> Self
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DataStreamRequest : MIBSFramework.Request {
  public typealias Handler<Success, Failure> = (MIBSFramework.DataStreamRequest.Stream<Success, Failure>) throws -> Swift.Void where Failure : Swift.Error
  public struct Stream<Success, Failure> where Failure : Swift.Error {
    public let event: MIBSFramework.DataStreamRequest.Event<Success, Failure>
    public let token: MIBSFramework.DataStreamRequest.CancellationToken
    public func cancel()
  }
  public enum Event<Success, Failure> where Failure : Swift.Error {
    case stream(Swift.Result<Success, Failure>)
    case complete(MIBSFramework.DataStreamRequest.Completion)
  }
  public struct Completion {
    public let request: Foundation.URLRequest?
    public let response: Foundation.HTTPURLResponse?
    public let metrics: Foundation.URLSessionTaskMetrics?
    public let error: MIBSFramework.AFError?
  }
  public struct CancellationToken {
    public func cancel()
  }
  final public let convertible: MIBSFramework.URLRequestConvertible
  final public let automaticallyCancelOnStreamError: Swift.Bool
  @discardableResult
  final public func validate(_ validation: @escaping MIBSFramework.DataStreamRequest.Validation) -> Self
  final public func asInputStream(bufferSize: Swift.Int = 1024) -> Foundation.InputStream?
  @objc deinit
}
extension MIBSFramework.DataStreamRequest.Stream {
  public var result: Swift.Result<Success, Failure>? {
    get
  }
  public var value: Success? {
    get
  }
  public var error: Failure? {
    get
  }
  public var completion: MIBSFramework.DataStreamRequest.Completion? {
    get
  }
}
@_hasMissingDesignatedInitializers public class DownloadRequest : MIBSFramework.Request {
  public struct Options : Swift.OptionSet {
    public static let createIntermediateDirectories: MIBSFramework.DownloadRequest.Options
    public static let removePreviousFile: MIBSFramework.DownloadRequest.Options
    public let rawValue: Swift.Int
    public init(rawValue: Swift.Int)
    public typealias ArrayLiteralElement = MIBSFramework.DownloadRequest.Options
    public typealias Element = MIBSFramework.DownloadRequest.Options
    public typealias RawValue = Swift.Int
  }
  public typealias Destination = (_ temporaryURL: Foundation.URL, _ response: Foundation.HTTPURLResponse) -> (destinationURL: Foundation.URL, options: MIBSFramework.DownloadRequest.Options)
  public class func suggestedDownloadDestination(for directory: Foundation.FileManager.SearchPathDirectory = .documentDirectory, in domain: Foundation.FileManager.SearchPathDomainMask = .userDomainMask, options: MIBSFramework.DownloadRequest.Options = []) -> MIBSFramework.DownloadRequest.Destination
  public enum Downloadable {
    case request(MIBSFramework.URLRequestConvertible)
    case resumeData(Foundation.Data)
  }
  public var resumeData: Foundation.Data? {
    get
  }
  public var fileURL: Foundation.URL? {
    get
  }
  final public let downloadable: MIBSFramework.DownloadRequest.Downloadable
  public func task(forResumeData data: Foundation.Data, using session: Foundation.URLSession) -> Foundation.URLSessionTask
  @discardableResult
  override public func cancel() -> Self
  @discardableResult
  public func cancel(producingResumeData shouldProduceResumeData: Swift.Bool) -> Self
  @discardableResult
  public func cancel(byProducingResumeData completionHandler: @escaping (_ data: Foundation.Data?) -> Swift.Void) -> Self
  @discardableResult
  public func validate(_ validation: @escaping MIBSFramework.DownloadRequest.Validation) -> Self
  @objc deinit
}
@_hasMissingDesignatedInitializers public class UploadRequest : MIBSFramework.DataRequest {
  public enum Uploadable {
    case data(Foundation.Data)
    case file(Foundation.URL, shouldRemove: Swift.Bool)
    case stream(Foundation.InputStream)
  }
  final public let upload: MIBSFramework.UploadableConvertible
  final public let fileManager: Foundation.FileManager
  public var uploadable: MIBSFramework.UploadRequest.Uploadable?
  public func cleanup()
  @objc deinit
}
public protocol UploadableConvertible {
  func createUploadable() throws -> MIBSFramework.UploadRequest.Uploadable
}
extension MIBSFramework.UploadRequest.Uploadable : MIBSFramework.UploadableConvertible {
  public func createUploadable() throws -> MIBSFramework.UploadRequest.Uploadable
}
public protocol UploadConvertible : MIBSFramework.URLRequestConvertible, MIBSFramework.UploadableConvertible {
}
@objc public protocol CardDetectionViewControllerDelegate {
  @objc func cardDetectionViewController(_ viewController: MIBSFramework.CardDetectionViewController, didDetectCard image: CoreGraphics.CGImage, withSettings settings: MIBSFramework.CardDetectionSettings)
  @objc optional func cardDetectionViewControllerDidCancel(_ viewController: MIBSFramework.CardDetectionViewController)
  @objc optional func qualityOfImage(_ image: CoreGraphics.CGImage) -> Foundation.NSNumber?
}
extension UIKit.UIDevice {
  @_Concurrency.MainActor(unsafe) public static let modelName: Swift.String
}
@objc open class SessionDelegate : ObjectiveC.NSObject {
  public init(fileManager: Foundation.FileManager = .default)
  @objc deinit
}
extension MIBSFramework.SessionDelegate : Foundation.URLSessionDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
}
extension MIBSFramework.SessionDelegate : Foundation.URLSessionTaskDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, needNewBodyStream completionHandler: @escaping (Foundation.InputStream?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
}
extension MIBSFramework.SessionDelegate : Foundation.URLSessionDataDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse, completionHandler: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
extension MIBSFramework.SessionDelegate : Foundation.URLSessionDownloadDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
}
open class SumTextFormatter : MIBSFramework.TextFormatter, MIBSFramework.TextUnformatter, MIBSFramework.TextNumberFormatter, MIBSFramework.TextNumberUnformatter {
  final public let numberFormatter: Foundation.NumberFormatter
  open var maximumIntegerCharacters: Swift.Int {
    get
    set
  }
  open var maximumDecimalCharacters: Swift.Int {
    get
  }
  open var prefix: Swift.String? {
    get
  }
  open var suffix: Swift.String? {
    get
  }
  open var groupingSeparator: Swift.String {
    get
  }
  open var decimalSeparator: Swift.String {
    get
  }
  open var groupingSize: Swift.Int {
    get
  }
  public init(numberFormatter: Foundation.NumberFormatter)
  convenience public init(textPattern: Swift.String, patternSymbol: Swift.Character = "#")
  open func format(_ unformatted: Swift.String?) -> Swift.String?
  open func format(_ number: Foundation.NSNumber) -> Swift.String?
  open func unformat(_ formatted: Swift.String?) -> Swift.String?
  open func unformatNumber(_ formattedText: Swift.String?) -> Foundation.NSNumber?
  @objc deinit
}
@objc final public class CompatibleAnimation : ObjectiveC.NSObject {
  @objc public init(name: Swift.String, bundle: Foundation.Bundle = Bundle.main)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc @_Concurrency.MainActor(unsafe) final public class CompatibleAnimationView : UIKit.UIView {
  @objc @_Concurrency.MainActor(unsafe) public init(compatibleAnimation: MIBSFramework.CompatibleAnimation)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @objc @_Concurrency.MainActor(unsafe) final public var compatibleAnimation: MIBSFramework.CompatibleAnimation? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public var loopAnimationCount: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override final public var contentMode: UIKit.UIView.ContentMode {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public var shouldRasterizeWhenIdle: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public var currentProgress: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public var currentTime: Foundation.TimeInterval {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public var currentFrame: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public var realtimeAnimationFrame: CoreFoundation.CGFloat {
    @objc get
  }
  @objc @_Concurrency.MainActor(unsafe) final public var realtimeAnimationProgress: CoreFoundation.CGFloat {
    @objc get
  }
  @objc @_Concurrency.MainActor(unsafe) final public var animationSpeed: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public var respectAnimationFrameRate: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public var isAnimationPlaying: Swift.Bool {
    @objc get
  }
  @objc @_Concurrency.MainActor(unsafe) final public func play()
  @objc @_Concurrency.MainActor(unsafe) final public func play(completion: ((Swift.Bool) -> Swift.Void)?)
  @objc @_Concurrency.MainActor(unsafe) final public func play(fromProgress: CoreFoundation.CGFloat, toProgress: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor(unsafe) final public func play(fromFrame: CoreFoundation.CGFloat, toFrame: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor(unsafe) final public func play(fromMarker: Swift.String, toMarker: Swift.String, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor(unsafe) final public func play(marker: Swift.String, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor(unsafe) final public func stop()
  @objc @_Concurrency.MainActor(unsafe) final public func pause()
  @objc @_Concurrency.MainActor(unsafe) final public func reloadImages()
  @objc @_Concurrency.MainActor(unsafe) final public func forceDisplayUpdate()
  @objc @_Concurrency.MainActor(unsafe) final public func getValue(for keypath: MIBSFramework.CompatibleAnimationKeypath, atFrame: CoreFoundation.CGFloat) -> Any?
  @objc @_Concurrency.MainActor(unsafe) final public func logHierarchyKeypaths()
  @objc @_Concurrency.MainActor(unsafe) final public func setColorValue(_ color: UIKit.UIColor, forKeypath keypath: MIBSFramework.CompatibleAnimationKeypath)
  @objc @_Concurrency.MainActor(unsafe) final public func getColorValue(for keypath: MIBSFramework.CompatibleAnimationKeypath, atFrame: CoreFoundation.CGFloat) -> UIKit.UIColor?
  @objc @_Concurrency.MainActor(unsafe) final public func addSubview(_ subview: MIBSFramework.AnimationSubview, forLayerAt keypath: MIBSFramework.CompatibleAnimationKeypath)
  @objc @_Concurrency.MainActor(unsafe) final public func convert(rect: CoreFoundation.CGRect, toLayerAt keypath: MIBSFramework.CompatibleAnimationKeypath?) -> CoreFoundation.CGRect
  @objc @_Concurrency.MainActor(unsafe) final public func convert(point: CoreFoundation.CGPoint, toLayerAt keypath: MIBSFramework.CompatibleAnimationKeypath?) -> CoreFoundation.CGPoint
  @objc @_Concurrency.MainActor(unsafe) final public func progressTime(forMarker named: Swift.String) -> CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor(unsafe) final public func frameTime(forMarker named: Swift.String) -> CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor(unsafe) final public func durationFrameTime(forMarker named: Swift.String) -> CoreFoundation.CGFloat
  @objc deinit
}
public typealias AFIDataResponse<T> = MIBSFramework.DataResponse<T, MIBSFramework.AFIError>
public typealias AFIResult<T> = Swift.Result<T, MIBSFramework.AFIError>
@_hasMissingDesignatedInitializers open class RequestReceipt {
  final public let request: MIBSFramework.DataRequest
  final public let receiptID: Swift.String
  @objc deinit
}
open class ImageDownloader {
  public typealias CompletionHandler = (MIBSFramework.AFIDataResponse<MIBSFramework.Image>) -> Swift.Void
  public typealias ProgressHandler = MIBSFramework.DataRequest.ProgressHandler
  public enum DownloadPrioritization {
    case fifo, lifo
    public static func == (a: MIBSFramework.ImageDownloader.DownloadPrioritization, b: MIBSFramework.ImageDownloader.DownloadPrioritization) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let imageCache: MIBSFramework.ImageRequestCache?
  open var credential: Foundation.URLCredential? {
    get
  }
  public var imageResponseSerializer: MIBSFramework.ImageResponseSerializer
  final public let session: MIBSFramework.Session
  public static let `default`: MIBSFramework.ImageDownloader
  open class func defaultURLSessionConfiguration() -> Foundation.URLSessionConfiguration
  open class func defaultURLCache() -> Foundation.URLCache
  public init(configuration: Foundation.URLSessionConfiguration = ImageDownloader.defaultURLSessionConfiguration(), downloadPrioritization: MIBSFramework.ImageDownloader.DownloadPrioritization = .fifo, maximumActiveDownloads: Swift.Int = 4, imageCache: MIBSFramework.ImageRequestCache? = AutoPurgingImageCache())
  public init(session: MIBSFramework.Session, downloadPrioritization: MIBSFramework.ImageDownloader.DownloadPrioritization = .fifo, maximumActiveDownloads: Swift.Int = 4, imageCache: MIBSFramework.ImageRequestCache? = AutoPurgingImageCache())
  open func addAuthentication(user: Swift.String, password: Swift.String, persistence: Foundation.URLCredential.Persistence = .forSession)
  open func addAuthentication(usingCredential credential: Foundation.URLCredential)
  @discardableResult
  open func download(_ urlRequest: MIBSFramework.URLRequestConvertible, cacheKey: Swift.String? = nil, receiptID: Swift.String = UUID().uuidString, serializer: MIBSFramework.ImageResponseSerializer? = nil, filter: MIBSFramework.ImageFilter? = nil, progress: MIBSFramework.ImageDownloader.ProgressHandler? = nil, progressQueue: Dispatch.DispatchQueue = DispatchQueue.main, completion: MIBSFramework.ImageDownloader.CompletionHandler? = nil) -> MIBSFramework.RequestReceipt?
  @discardableResult
  open func download(_ urlRequests: [MIBSFramework.URLRequestConvertible], filter: MIBSFramework.ImageFilter? = nil, progress: MIBSFramework.ImageDownloader.ProgressHandler? = nil, progressQueue: Dispatch.DispatchQueue = DispatchQueue.main, completion: MIBSFramework.ImageDownloader.CompletionHandler? = nil) -> [MIBSFramework.RequestReceipt]
  open func cancelRequest(with requestReceipt: MIBSFramework.RequestReceipt)
  @objc deinit
}
@objc @_Concurrency.MainActor(unsafe) open class HeaderView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) open var closeButton: UIKit.UIButton {
    get
  }
  @_Concurrency.MainActor(unsafe) open var deleteButton: UIKit.UIButton {
    get
  }
  @_Concurrency.MainActor(unsafe) @objc dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
extension MIBSFramework.HeaderView {
  @objc @_Concurrency.MainActor(unsafe) dynamic public func configureLayout()
}
public typealias AFDataResponse<Success> = MIBSFramework.DataResponse<Success, MIBSFramework.AFError>
public typealias AFDownloadResponse<Success> = MIBSFramework.DownloadResponse<Success, MIBSFramework.AFError>
public struct DataResponse<Success, Failure> where Failure : Swift.Error {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let data: Foundation.Data?
  public let metrics: Foundation.URLSessionTaskMetrics?
  public let serializationDuration: Foundation.TimeInterval
  public let result: Swift.Result<Success, Failure>
  public var value: Success? {
    get
  }
  public var error: Failure? {
    get
  }
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, metrics: Foundation.URLSessionTaskMetrics?, serializationDuration: Foundation.TimeInterval, result: Swift.Result<Success, Failure>)
}
extension MIBSFramework.DataResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension MIBSFramework.DataResponse {
  public func map<NewSuccess>(_ transform: (Success) -> NewSuccess) -> MIBSFramework.DataResponse<NewSuccess, Failure>
  public func tryMap<NewSuccess>(_ transform: (Success) throws -> NewSuccess) -> MIBSFramework.DataResponse<NewSuccess, Swift.Error>
  public func mapError<NewFailure>(_ transform: (Failure) -> NewFailure) -> MIBSFramework.DataResponse<Success, NewFailure> where NewFailure : Swift.Error
  public func tryMapError<NewFailure>(_ transform: (Failure) throws -> NewFailure) -> MIBSFramework.DataResponse<Success, Swift.Error> where NewFailure : Swift.Error
}
public struct DownloadResponse<Success, Failure> where Failure : Swift.Error {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let fileURL: Foundation.URL?
  public let resumeData: Foundation.Data?
  public let metrics: Foundation.URLSessionTaskMetrics?
  public let serializationDuration: Foundation.TimeInterval
  public let result: Swift.Result<Success, Failure>
  public var value: Success? {
    get
  }
  public var error: Failure? {
    get
  }
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, resumeData: Foundation.Data?, metrics: Foundation.URLSessionTaskMetrics?, serializationDuration: Foundation.TimeInterval, result: Swift.Result<Success, Failure>)
}
extension MIBSFramework.DownloadResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension MIBSFramework.DownloadResponse {
  public func map<NewSuccess>(_ transform: (Success) -> NewSuccess) -> MIBSFramework.DownloadResponse<NewSuccess, Failure>
  public func tryMap<NewSuccess>(_ transform: (Success) throws -> NewSuccess) -> MIBSFramework.DownloadResponse<NewSuccess, Swift.Error>
  public func mapError<NewFailure>(_ transform: (Failure) -> NewFailure) -> MIBSFramework.DownloadResponse<Success, NewFailure> where NewFailure : Swift.Error
  public func tryMapError<NewFailure>(_ transform: (Failure) throws -> NewFailure) -> MIBSFramework.DownloadResponse<Success, Swift.Error> where NewFailure : Swift.Error
}
final public class FloatValueProvider {
  public init(block: @escaping MIBSFramework.FloatValueProvider.CGFloatValueBlock)
  public init(_ float: CoreFoundation.CGFloat)
  public typealias CGFloatValueBlock = (CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public var float: CoreFoundation.CGFloat {
    get
    set
  }
  final public var valueType: Any.Type {
    get
  }
  final public var storage: MIBSFramework.ValueProviderStorage<MIBSFramework.Vector1D> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
public enum ColorFormatDenominator : Swift.Hashable {
  case One
  case OneHundred
  case TwoFiftyFive
  public static func == (a: MIBSFramework.ColorFormatDenominator, b: MIBSFramework.ColorFormatDenominator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct Color : Swift.Hashable {
  public var r: Swift.Double
  public var g: Swift.Double
  public var b: Swift.Double
  public var a: Swift.Double
  public init(r: Swift.Double, g: Swift.Double, b: Swift.Double, a: Swift.Double, denominator: MIBSFramework.ColorFormatDenominator = .One)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: MIBSFramework.Color, b: MIBSFramework.Color) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @objc public class BarcodeDetectionSettings : MIBSFramework.BaseBarcodeDetectionSettings, MIBSFramework.TorchSettings {
  @objc public var torchLevel: Swift.Float
  @objc override public init(barcodeSymbologies: [Vision.VNBarcodeSymbology]) throws
  @objc deinit
}
@objc public class BaseBarcodeDetectionSettings : ObjectiveC.NSObject {
  @objc final public let barcodeSymbologies: [Vision.VNBarcodeSymbology]
  @objc public init(barcodeSymbologies: [Vision.VNBarcodeSymbology]) throws
  @objc deinit
}
@objc public enum BarcodeDetectionSettingsError : Swift.Int, Swift.Error {
  case unsupportedBarcodeSymbology
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public static var _nsErrorDomain: Swift.String {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class ImageAsset : MIBSFramework.Asset {
  final public let name: Swift.String
  final public let directory: Swift.String
  final public let width: Swift.Double
  final public let height: Swift.Double
  override final public func encode(to encoder: Swift.Encoder) throws
  @objc deinit
}
extension Foundation.DateFormatter {
  convenience public init(withFormat format: Swift.String, locale: Swift.String)
}
open class ISO8601DateTransform : MIBSFramework.DateFormatterTransform {
  public init()
  @objc deinit
}
extension QuartzCore.CALayer {
  @nonobjc public func logLayerTree(withIndent: Swift.Int = 0)
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class BaseCardDetectionViewController : MIBSFramework.ObjectDetectionViewController {
  @_Concurrency.MainActor(unsafe) @objc dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func observeValue(forKeyPath keyPath: Swift.String?, of object: Any?, change: [Foundation.NSKeyValueChangeKey : Any]?, context: Swift.UnsafeMutableRawPointer?)
  @_Concurrency.MainActor(unsafe) @objc override public func presentationControllerDidDismiss(_ presentationController: UIKit.UIPresentationController)
  @objc deinit
}
public protocol ImmutableMappable : MIBSFramework.BaseMappable {
  init(map: MIBSFramework.Map) throws
}
extension MIBSFramework.ImmutableMappable {
  public func mapping(map: MIBSFramework.Map)
  public init(JSONString: Swift.String, context: MIBSFramework.MapContext? = nil) throws
  public init(JSON: [Swift.String : Any], context: MIBSFramework.MapContext? = nil) throws
  public init(JSONObject: Any, context: MIBSFramework.MapContext? = nil) throws
}
extension MIBSFramework.Map {
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> T
  final public func value<Transform>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", using transform: Transform, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> Transform.Object where Transform : MIBSFramework.TransformType
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> T where T : Swift.RawRepresentable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> T? where T : Swift.RawRepresentable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [T] where T : Swift.RawRepresentable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [T]? where T : Swift.RawRepresentable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> T where T : MIBSFramework.BaseMappable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> T? where T : MIBSFramework.BaseMappable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [T] where T : MIBSFramework.BaseMappable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [T]? where T : MIBSFramework.BaseMappable
  final public func value<Transform>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", using transform: Transform, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [Transform.Object] where Transform : MIBSFramework.TransformType
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [Swift.String : T] where T : MIBSFramework.BaseMappable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [Swift.String : T]? where T : MIBSFramework.BaseMappable
  final public func value<Transform>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", using transform: Transform, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [Swift.String : Transform.Object] where Transform : MIBSFramework.TransformType
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [[T]]? where T : MIBSFramework.BaseMappable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [[T]] where T : MIBSFramework.BaseMappable
  final public func value<Transform>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", using transform: Transform, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [[Transform.Object]] where Transform : MIBSFramework.TransformType
}
extension MIBSFramework.Mapper where N : MIBSFramework.ImmutableMappable {
  final public func map(JSON: [Swift.String : Any]) throws -> N
  final public func map(JSONString: Swift.String) throws -> N
  final public func map(JSONObject: Any) throws -> N
  final public func mapArray(JSONArray: [[Swift.String : Any]]) throws -> [N]
  final public func mapArray(JSONString: Swift.String) throws -> [N]
  final public func mapArray(JSONObject: Any) throws -> [N]
  final public func mapDictionary(JSONString: Swift.String) throws -> [Swift.String : N]
  final public func mapDictionary(JSONObject: Any?) throws -> [Swift.String : N]
  final public func mapDictionary(JSON: [Swift.String : [Swift.String : Any]]) throws -> [Swift.String : N]
  final public func mapDictionaryOfArrays(JSONObject: Any?) throws -> [Swift.String : [N]]
  final public func mapDictionaryOfArrays(JSON: [Swift.String : [[Swift.String : Any]]]) throws -> [Swift.String : [N]]
  final public func mapArrayOfArrays(JSONObject: Any?) throws -> [[N]]
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class AnimationViewBase : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var contentMode: UIKit.UIView.ContentMode {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func didMoveToWindow()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension UIKit.UIImage : MIBSFramework.AlamofireExtended {
  public typealias ExtendedType = UIKit.UIImage
}
extension MIBSFramework.AlamofireExtension where ExtendedType : UIKit.UIImage {
  public static func threadSafeImage(with data: Foundation.Data) -> UIKit.UIImage?
  public static func threadSafeImage(with data: Foundation.Data, scale: CoreFoundation.CGFloat) -> UIKit.UIImage?
}
extension UIKit.UIImage {
  @available(*, deprecated, message: "Replaced by `UIImage.af.threadSafeImage(with:)`")
  public static func af_threadSafeImage(with data: Foundation.Data) -> UIKit.UIImage?
  @available(*, deprecated, message: "Replaced by `UIImage.af.threadSafeImage(with:scale:)`")
  public static func af_threadSafeImage(with data: Foundation.Data, scale: CoreFoundation.CGFloat) -> UIKit.UIImage?
}
extension MIBSFramework.AlamofireExtension where ExtendedType : UIKit.UIImage {
  public var isInflated: Swift.Bool {
    get
    nonmutating set
  }
  public func inflate()
}
extension UIKit.UIImage {
  @available(*, deprecated, message: "Replaced by `image.af.isInflated`")
  public var af_inflated: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Replaced by `image.af.inflate()`")
  public func af_inflate()
}
extension MIBSFramework.AlamofireExtension where ExtendedType : UIKit.UIImage {
  public var containsAlphaComponent: Swift.Bool {
    get
  }
  public var isOpaque: Swift.Bool {
    get
  }
}
extension UIKit.UIImage {
  @available(*, deprecated, message: "Replaced by `image.af.containsAlphaComponent`")
  public var af_containsAlphaComponent: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Replaced by `image.af.isOpaque`")
  public var af_isOpaque: Swift.Bool {
    get
  }
}
extension MIBSFramework.AlamofireExtension where ExtendedType : UIKit.UIImage {
  public func imageScaled(to size: CoreFoundation.CGSize, scale: CoreFoundation.CGFloat? = nil) -> UIKit.UIImage
  public func imageAspectScaled(toFit size: CoreFoundation.CGSize, scale: CoreFoundation.CGFloat? = nil) -> UIKit.UIImage
  public func imageAspectScaled(toFill size: CoreFoundation.CGSize, scale: CoreFoundation.CGFloat? = nil) -> UIKit.UIImage
}
extension UIKit.UIImage {
  @available(*, deprecated, message: "Replaced by `image.af.imageScale(to:scale:)`")
  public func af_imageScaled(to size: CoreFoundation.CGSize, scale: CoreFoundation.CGFloat? = nil) -> UIKit.UIImage
  @available(*, deprecated, message: "Replaced by `image.af.imageAspectScale(toFit:scale:)`")
  public func af_imageAspectScaled(toFit size: CoreFoundation.CGSize, scale: CoreFoundation.CGFloat? = nil) -> UIKit.UIImage
  @available(*, deprecated, message: "Replaced by `image.af.imageAspectScale(toFill:scale:)`")
  public func af_imageAspectScaled(toFill size: CoreFoundation.CGSize, scale: CoreFoundation.CGFloat? = nil) -> UIKit.UIImage
}
extension MIBSFramework.AlamofireExtension where ExtendedType : UIKit.UIImage {
  public func imageRounded(withCornerRadius radius: CoreFoundation.CGFloat, divideRadiusByImageScale: Swift.Bool = false) -> UIKit.UIImage
  public func imageRoundedIntoCircle() -> UIKit.UIImage
}
extension UIKit.UIImage {
  @available(*, deprecated, message: "Replaced by `image.af.imageRounded(withCornerRadius:divideRadiusByImageScale:)`")
  public func af_imageRounded(withCornerRadius radius: CoreFoundation.CGFloat, divideRadiusByImageScale: Swift.Bool = false) -> UIKit.UIImage
  @available(*, deprecated, message: "Replaced by `image.af.imageRoundedIntoCircle()`")
  public func af_imageRoundedIntoCircle() -> UIKit.UIImage
}
extension MIBSFramework.AlamofireExtension where ExtendedType : UIKit.UIImage {
  public func imageFiltered(withCoreImageFilter name: Swift.String, parameters: [Swift.String : Any]? = nil) -> UIKit.UIImage?
}
extension UIKit.UIImage {
  @available(*, deprecated, message: "Replaced by `image.af.imageFiltered(withCoreImageFilter:parameters:)`")
  public func af_imageFiltered(withCoreImageFilter name: Swift.String, parameters: [Swift.String : Any]? = nil) -> UIKit.UIImage?
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class TextViewInputController : ObjectiveC.NSObject, UIKit.UITextViewDelegate {
  @_Concurrency.MainActor(unsafe) open var formatter: MIBSFramework.TextInputFormatter?
  @_Concurrency.MainActor(unsafe) @objc open func textView(_ textView: UIKit.UITextView, shouldChangeTextIn range: Foundation.NSRange, replacementText text: Swift.String) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init()
  @objc deinit
}
public struct AnimationKeypath : Swift.Hashable, Swift.ExpressibleByStringLiteral {
  public init(keypath: Swift.String)
  public init(stringLiteral: Swift.String)
  public init(keys: [Swift.String])
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: MIBSFramework.AnimationKeypath, b: MIBSFramework.AnimationKeypath) -> Swift.Bool
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
  public var hashValue: Swift.Int {
    get
  }
}
public protocol LightboxControllerPageDelegate : AnyObject {
  func lightboxController(_ controller: MIBSFramework.LightboxController, didMoveToPage page: Swift.Int)
}
public protocol LightboxControllerDismissalDelegate : AnyObject {
  func lightboxControllerWillDismiss(_ controller: MIBSFramework.LightboxController)
}
public protocol LightboxControllerTouchDelegate : AnyObject {
  func lightboxController(_ controller: MIBSFramework.LightboxController, didTouch image: MIBSFramework.LightboxImage, at index: Swift.Int)
}
public protocol LightboxControllerDeleteDelegate : AnyObject {
  func lightboxController(_ controller: MIBSFramework.LightboxController, willDeleteAt index: Swift.Int)
}
@objc @_Concurrency.MainActor(unsafe) open class LightboxController : UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) open var headerView: MIBSFramework.HeaderView {
    get
  }
  @_Concurrency.MainActor(unsafe) open var footerView: MIBSFramework.FooterView {
    get
  }
  @_Concurrency.MainActor(unsafe) open var overlayView: UIKit.UIView {
    get
  }
  @_Concurrency.MainActor(unsafe) open var currentPage: Swift.Int {
    get
  }
  @_Concurrency.MainActor(unsafe) open var numberOfPages: Swift.Int {
    get
  }
  @_Concurrency.MainActor(unsafe) open var dynamicBackground: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) open var spacing: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) open var images: [MIBSFramework.LightboxImage] {
    get
    set(value)
  }
  @_Concurrency.MainActor(unsafe) weak open var pageDelegate: MIBSFramework.LightboxControllerPageDelegate?
  @_Concurrency.MainActor(unsafe) weak open var dismissalDelegate: MIBSFramework.LightboxControllerDismissalDelegate?
  @_Concurrency.MainActor(unsafe) weak open var imageTouchDelegate: MIBSFramework.LightboxControllerTouchDelegate?
  @_Concurrency.MainActor(unsafe) weak open var imageDeleteDelegate: MIBSFramework.LightboxControllerDeleteDelegate?
  @_Concurrency.MainActor(unsafe) open var presented: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) open var seen: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) public init(images: [MIBSFramework.LightboxImage] = [], startIndex index: Swift.Int = 0)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewDidLayoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var prefersStatusBarHidden: Swift.Bool {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewWillTransition(to size: CoreFoundation.CGSize, with coordinator: UIKit.UIViewControllerTransitionCoordinator)
  @_Concurrency.MainActor(unsafe) open func goTo(_ page: Swift.Int, animated: Swift.Bool = true)
  @_Concurrency.MainActor(unsafe) open func next(_ animated: Swift.Bool = true)
  @_Concurrency.MainActor(unsafe) open func previous(_ animated: Swift.Bool = true)
  @_Concurrency.MainActor(unsafe) open func configureLayout(_ size: CoreFoundation.CGSize)
  @objc deinit
}
extension MIBSFramework.LightboxController : UIKit.UIScrollViewDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func scrollViewWillEndDragging(_ scrollView: UIKit.UIScrollView, withVelocity velocity: CoreFoundation.CGPoint, targetContentOffset: Swift.UnsafeMutablePointer<CoreFoundation.CGPoint>)
}
extension MIBSFramework.LightboxController : MIBSFramework.FooterViewDelegate {
  @_Concurrency.MainActor(unsafe) public func footerView(_ footerView: MIBSFramework.FooterView, didExpand expanded: Swift.Bool)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class TextFieldInputController : ObjectiveC.NSObject, UIKit.UITextFieldDelegate {
  @_Concurrency.MainActor(unsafe) open var formatter: MIBSFramework.TextInputFormatter?
  @_Concurrency.MainActor(unsafe) @objc open func textField(_ textField: UIKit.UITextField, shouldChangeCharactersIn range: Foundation.NSRange, replacementString string: Swift.String) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init()
  @objc deinit
}
final public class ColorValueProvider {
  public init(block: @escaping MIBSFramework.ColorValueProvider.ColorValueBlock)
  public init(_ color: MIBSFramework.Color)
  public init(_ keyframes: [MIBSFramework.Keyframe<MIBSFramework.Color>])
  public typealias ColorValueBlock = (CoreFoundation.CGFloat) -> MIBSFramework.Color
  final public var color: MIBSFramework.Color {
    get
    set
  }
  final public var valueType: Any.Type {
    get
  }
  final public var storage: MIBSFramework.ValueProviderStorage<MIBSFramework.Color> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
public typealias ControlState = UIKit.UIControl.State
extension UIKit.UIButton : MIBSFramework.AlamofireExtended {
  public typealias ExtendedType = UIKit.UIButton
}
extension MIBSFramework.AlamofireExtension where ExtendedType : UIKit.UIButton {
  public var imageDownloader: MIBSFramework.ImageDownloader? {
    get
    nonmutating set
  }
  public static var sharedImageDownloader: MIBSFramework.ImageDownloader {
    get
    set
  }
  public func setImage(for state: MIBSFramework.ControlState, url: Foundation.URL, cacheKey: Swift.String? = nil, placeholderImage: UIKit.UIImage? = nil, serializer: MIBSFramework.ImageResponseSerializer? = nil, filter: MIBSFramework.ImageFilter? = nil, progress: MIBSFramework.ImageDownloader.ProgressHandler? = nil, progressQueue: Dispatch.DispatchQueue = DispatchQueue.main, completion: ((MIBSFramework.AFIDataResponse<UIKit.UIImage>) -> Swift.Void)? = nil)
  public func setImage(for state: MIBSFramework.ControlState, urlRequest: MIBSFramework.URLRequestConvertible, cacheKey: Swift.String? = nil, placeholderImage: UIKit.UIImage? = nil, serializer: MIBSFramework.ImageResponseSerializer? = nil, filter: MIBSFramework.ImageFilter? = nil, progress: MIBSFramework.ImageDownloader.ProgressHandler? = nil, progressQueue: Dispatch.DispatchQueue = DispatchQueue.main, completion: ((MIBSFramework.AFIDataResponse<UIKit.UIImage>) -> Swift.Void)? = nil)
  public func cancelImageRequest(for state: MIBSFramework.ControlState)
  public func setBackgroundImage(for state: MIBSFramework.ControlState, url: Foundation.URL, cacheKey: Swift.String? = nil, placeholderImage: UIKit.UIImage? = nil, serializer: MIBSFramework.ImageResponseSerializer? = nil, filter: MIBSFramework.ImageFilter? = nil, progress: MIBSFramework.ImageDownloader.ProgressHandler? = nil, progressQueue: Dispatch.DispatchQueue = DispatchQueue.main, completion: ((MIBSFramework.AFIDataResponse<UIKit.UIImage>) -> Swift.Void)? = nil)
  public func setBackgroundImage(for state: MIBSFramework.ControlState, urlRequest: MIBSFramework.URLRequestConvertible, cacheKey: Swift.String? = nil, placeholderImage: UIKit.UIImage? = nil, serializer: MIBSFramework.ImageResponseSerializer? = nil, filter: MIBSFramework.ImageFilter? = nil, progress: MIBSFramework.ImageDownloader.ProgressHandler? = nil, progressQueue: Dispatch.DispatchQueue = DispatchQueue.main, completion: ((MIBSFramework.AFIDataResponse<UIKit.UIImage>) -> Swift.Void)? = nil)
  public func cancelBackgroundImageRequest(for state: MIBSFramework.ControlState)
}
extension UIKit.UIButton {
  @available(*, deprecated, message: "Replaced by `button.af.imageDownloader`")
  @_Concurrency.MainActor(unsafe) public var af_imageDownloader: MIBSFramework.ImageDownloader? {
    get
    set
  }
  @available(*, deprecated, message: "Replaced by `button.af.sharedImageDownloader`")
  @_Concurrency.MainActor(unsafe) public class var af_sharedImageDownloader: MIBSFramework.ImageDownloader {
    get
    set
  }
  @available(*, deprecated, message: "Replaced by `button.af.sharedImageDownloader`")
  @_Concurrency.MainActor(unsafe) public func af_setImage(for state: MIBSFramework.ControlState, url: Foundation.URL, cacheKey: Swift.String? = nil, placeholderImage: UIKit.UIImage? = nil, serializer: MIBSFramework.ImageResponseSerializer? = nil, filter: MIBSFramework.ImageFilter? = nil, progress: MIBSFramework.ImageDownloader.ProgressHandler? = nil, progressQueue: Dispatch.DispatchQueue = DispatchQueue.main, completion: ((MIBSFramework.AFIDataResponse<UIKit.UIImage>) -> Swift.Void)? = nil)
  @available(*, deprecated, message: "Replaced by `button.af.sharedImageDownloader`")
  @_Concurrency.MainActor(unsafe) public func af_setImage(for state: MIBSFramework.ControlState, urlRequest: MIBSFramework.URLRequestConvertible, cacheKey: Swift.String? = nil, placeholderImage: UIKit.UIImage? = nil, serializer: MIBSFramework.ImageResponseSerializer? = nil, filter: MIBSFramework.ImageFilter? = nil, progress: MIBSFramework.ImageDownloader.ProgressHandler? = nil, progressQueue: Dispatch.DispatchQueue = DispatchQueue.main, completion: ((MIBSFramework.AFIDataResponse<UIKit.UIImage>) -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) public func af_cancelImageRequest(for state: MIBSFramework.ControlState)
  @available(*, deprecated, message: "Replaced by `button.af.sharedImageDownloader`")
  @_Concurrency.MainActor(unsafe) public func af_setBackgroundImage(for state: MIBSFramework.ControlState, url: Foundation.URL, cacheKey: Swift.String? = nil, placeholderImage: UIKit.UIImage? = nil, serializer: MIBSFramework.ImageResponseSerializer? = nil, filter: MIBSFramework.ImageFilter? = nil, progress: MIBSFramework.ImageDownloader.ProgressHandler? = nil, progressQueue: Dispatch.DispatchQueue = DispatchQueue.main, completion: ((MIBSFramework.AFIDataResponse<UIKit.UIImage>) -> Swift.Void)? = nil)
  @available(*, deprecated, message: "Replaced by `button.af.sharedImageDownloader`")
  @_Concurrency.MainActor(unsafe) public func af_setBackgroundImage(for state: MIBSFramework.ControlState, urlRequest: MIBSFramework.URLRequestConvertible, cacheKey: Swift.String? = nil, placeholderImage: UIKit.UIImage? = nil, serializer: MIBSFramework.ImageResponseSerializer? = nil, filter: MIBSFramework.ImageFilter? = nil, progress: MIBSFramework.ImageDownloader.ProgressHandler? = nil, progressQueue: Dispatch.DispatchQueue = DispatchQueue.main, completion: ((MIBSFramework.AFIDataResponse<UIKit.UIImage>) -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) public func af_cancelBackgroundImageRequest(for state: MIBSFramework.ControlState)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class ObjectDetectionViewController : UIKit.UIViewController, UIKit.UIAdaptivePresentationControllerDelegate {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var prefersStatusBarHidden: Swift.Bool {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillTransition(to size: CoreFoundation.CGSize, with coordinator: UIKit.UIViewControllerTransitionCoordinator)
  @_Concurrency.MainActor(unsafe) @objc public func presentationControllerDidDismiss(_ presentationController: UIKit.UIPresentationController)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
final public class GradientValueProvider {
  public init(block: @escaping MIBSFramework.GradientValueProvider.ColorsValueBlock, locations: MIBSFramework.GradientValueProvider.ColorLocationsBlock? = nil)
  public init(_ colors: [MIBSFramework.Color], locations: [Swift.Double] = [])
  public typealias ColorsValueBlock = (CoreFoundation.CGFloat) -> [MIBSFramework.Color]
  public typealias ColorLocationsBlock = (CoreFoundation.CGFloat) -> [Swift.Double]
  final public var colors: [MIBSFramework.Color] {
    get
    set
  }
  final public var locations: [Swift.Double] {
    get
    set
  }
  final public var valueType: Any.Type {
    get
  }
  final public var storage: MIBSFramework.ValueProviderStorage<[Swift.Double]> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
extension UIKit.UIColor {
  public var lottieColorValue: MIBSFramework.Color {
    get
  }
}
public typealias Image = UIKit.UIImage
final public class SizeValueProvider {
  public init(block: @escaping MIBSFramework.SizeValueProvider.SizeValueBlock)
  public init(_ size: CoreFoundation.CGSize)
  public typealias SizeValueBlock = (CoreFoundation.CGFloat) -> CoreFoundation.CGSize
  final public var size: CoreFoundation.CGSize {
    get
    set
  }
  final public var valueType: Any.Type {
    get
  }
  final public var storage: MIBSFramework.ValueProviderStorage<MIBSFramework.Vector3D> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) final public class AnimationSubview : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension MIBSFramework.Color : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public protocol FooterViewDelegate : AnyObject {
  func footerView(_ footerView: MIBSFramework.FooterView, didExpand expanded: Swift.Bool)
}
@objc @_Concurrency.MainActor(unsafe) open class FooterView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) open var infoLabel: MIBSFramework.InfoLabel {
    get
  }
  @_Concurrency.MainActor(unsafe) open var pageLabel: UIKit.UILabel {
    get
  }
  @_Concurrency.MainActor(unsafe) open var separatorView: UIKit.UIView {
    get
  }
  @_Concurrency.MainActor(unsafe) weak open var delegate: MIBSFramework.FooterViewDelegate?
  @_Concurrency.MainActor(unsafe) @objc dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func layoutSubviews()
  @objc deinit
}
extension MIBSFramework.FooterView {
  @objc @_Concurrency.MainActor(unsafe) dynamic public func configureLayout()
}
extension MIBSFramework.FooterView : MIBSFramework.InfoLabelDelegate {
  @_Concurrency.MainActor(unsafe) public func infoLabel(_ infoLabel: MIBSFramework.InfoLabel, didExpand expanded: Swift.Bool)
}
public protocol AnyValueProvider {
  var valueType: Any.Type { get }
  var typeErasedStorage: MIBSFramework.AnyValueProviderStorage { get }
  func hasUpdate(frame: MIBSFramework.AnimationFrameTime) -> Swift.Bool
}
extension MIBSFramework.AnyValueProvider {
  public func value(frame: MIBSFramework.AnimationFrameTime) -> Any
}
public enum ValueProviderStorage<T> where T : MIBSFramework.AnyInterpolatable {
  case singleValue(T)
  case keyframes([MIBSFramework.Keyframe<T>])
  case closure((MIBSFramework.AnimationFrameTime) -> T)
}
public enum AnyValueProviderStorage {
  case singleValue(Any)
  case keyframes([MIBSFramework.Keyframe<Any>], interpolate: (MIBSFramework.AnimationFrameTime) -> Any)
  case closure((MIBSFramework.AnimationFrameTime) -> Any)
}
public enum MappingType {
  case fromJSON
  case toJSON
  public static func == (a: MIBSFramework.MappingType, b: MIBSFramework.MappingType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class Mapper<N> where N : MIBSFramework.BaseMappable {
  final public var context: MIBSFramework.MapContext?
  final public var shouldIncludeNilValues: Swift.Bool
  public init(context: MIBSFramework.MapContext? = nil, shouldIncludeNilValues: Swift.Bool = false)
  final public func map(JSONObject: Any?, toObject object: N) -> N
  final public func map(JSONString: Swift.String, toObject object: N) -> N
  final public func map(JSON: [Swift.String : Any], toObject object: N) -> N
  final public func map(JSONString: Swift.String) -> N?
  final public func map(JSONObject: Any?) -> N?
  final public func map(JSON: [Swift.String : Any]) -> N?
  final public func mapArray(JSONString: Swift.String) -> [N]?
  final public func mapArray(JSONObject: Any?) -> [N]?
  final public func mapArray(JSONArray: [[Swift.String : Any]]) -> [N]
  final public func mapDictionary(JSONString: Swift.String) -> [Swift.String : N]?
  final public func mapDictionary(JSONObject: Any?) -> [Swift.String : N]?
  final public func mapDictionary(JSON: [Swift.String : [Swift.String : Any]]) -> [Swift.String : N]?
  final public func mapDictionary(JSONObject: Any?, toDictionary dictionary: [Swift.String : N]) -> [Swift.String : N]
  final public func mapDictionary(JSON: [Swift.String : [Swift.String : Any]], toDictionary dictionary: [Swift.String : N]) -> [Swift.String : N]
  final public func mapDictionaryOfArrays(JSONObject: Any?) -> [Swift.String : [N]]?
  final public func mapDictionaryOfArrays(JSON: [Swift.String : [[Swift.String : Any]]]) -> [Swift.String : [N]]?
  final public func mapArrayOfArrays(JSONObject: Any?) -> [[N]]?
  public static func parseJSONStringIntoDictionary(JSONString: Swift.String) -> [Swift.String : Any]?
  public static func parseJSONString(JSONString: Swift.String) -> Any?
  @objc deinit
}
extension MIBSFramework.Mapper {
  final public func map(JSONfile: Swift.String) -> N?
  final public func mapArray(JSONfile: Swift.String) -> [N]?
}
extension MIBSFramework.Mapper {
  final public func toJSON(_ object: N) -> [Swift.String : Any]
  final public func toJSONArray(_ array: [N]) -> [[Swift.String : Any]]
  final public func toJSONDictionary(_ dictionary: [Swift.String : N]) -> [Swift.String : [Swift.String : Any]]
  final public func toJSONDictionaryOfArrays(_ dictionary: [Swift.String : [N]]) -> [Swift.String : [[Swift.String : Any]]]
  final public func toJSONString(_ object: N, prettyPrint: Swift.Bool = false) -> Swift.String?
  final public func toJSONString(_ array: [N], prettyPrint: Swift.Bool = false) -> Swift.String?
  public static func toJSONString(_ JSONObject: Any, prettyPrint: Swift.Bool) -> Swift.String?
  public static func toJSONData(_ JSONObject: Any, options: Foundation.JSONSerialization.WritingOptions) -> Foundation.Data?
}
extension MIBSFramework.Mapper where N : Swift.Hashable {
  final public func mapSet(JSONString: Swift.String) -> Swift.Set<N>?
  final public func mapSet(JSONObject: Any?) -> Swift.Set<N>?
  final public func mapSet(JSONArray: [[Swift.String : Any]]) -> Swift.Set<N>
  final public func toJSONSet(_ set: Swift.Set<N>) -> [[Swift.String : Any]]
  final public func toJSONString(_ set: Swift.Set<N>, prettyPrint: Swift.Bool = false) -> Swift.String?
}
@available(iOSApplicationExtension, unavailable)
@objc final public class IQInvocation : ObjectiveC.NSObject {
  @objc weak final public var target: Swift.AnyObject?
  @objc final public var action: ObjectiveC.Selector
  @objc public init(_ target: Swift.AnyObject, _ action: ObjectiveC.Selector)
  @objc final public func invoke(from: Any)
  @objc deinit
}
public struct FormattedTextValue : Swift.Equatable {
  public let formattedText: Swift.String
  public let caretBeginOffset: Swift.Int
  public init(formattedText: Swift.String, caretBeginOffset: Swift.Int)
  public static var zero: MIBSFramework.FormattedTextValue {
    get
  }
  public static func == (a: MIBSFramework.FormattedTextValue, b: MIBSFramework.FormattedTextValue) -> Swift.Bool
}
public enum AFIError : Swift.Error {
  case requestCancelled
  case imageSerializationFailed
  case alamofireError(MIBSFramework.AFError)
}
extension MIBSFramework.AFIError {
  public var isRequestCancelledError: Swift.Bool {
    get
  }
  public var isImageSerializationFailedError: Swift.Bool {
    get
  }
  public var isAlamofireError: Swift.Bool {
    get
  }
}
extension MIBSFramework.AFIError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
open class PlaceholderTextInputFormatter : MIBSFramework.TextInputFormatter, MIBSFramework.TextFormatter, MIBSFramework.TextUnformatter, MIBSFramework.CaretPositioner {
  public init(textPattern: Swift.String, patternSymbol: Swift.Character = "#")
  open func formatInput(currentText: Swift.String, range: Foundation.NSRange, replacementString text: Swift.String) -> MIBSFramework.FormattedTextValue
  open func getCaretOffset(for text: Swift.String) -> Swift.Int
  open func format(_ unformattedText: Swift.String?) -> Swift.String?
  open func unformat(_ formattedText: Swift.String?) -> Swift.String?
  @objc deinit
}
public struct HTTPHeaders {
  public init()
  public init(_ headers: [MIBSFramework.HTTPHeader])
  public init(_ dictionary: [Swift.String : Swift.String])
  public mutating func add(name: Swift.String, value: Swift.String)
  public mutating func add(_ header: MIBSFramework.HTTPHeader)
  public mutating func update(name: Swift.String, value: Swift.String)
  public mutating func update(_ header: MIBSFramework.HTTPHeader)
  public mutating func remove(name: Swift.String)
  public mutating func sort()
  public func sorted() -> MIBSFramework.HTTPHeaders
  public func value(for name: Swift.String) -> Swift.String?
  public subscript(name: Swift.String) -> Swift.String? {
    get
    set
  }
  public var dictionary: [Swift.String : Swift.String] {
    get
  }
}
extension MIBSFramework.HTTPHeaders : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Swift.String, Swift.String)...)
  public typealias Key = Swift.String
  public typealias Value = Swift.String
}
extension MIBSFramework.HTTPHeaders : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: MIBSFramework.HTTPHeader...)
  public typealias ArrayLiteralElement = MIBSFramework.HTTPHeader
}
extension MIBSFramework.HTTPHeaders : Swift.Sequence {
  public func makeIterator() -> Swift.IndexingIterator<[MIBSFramework.HTTPHeader]>
}
extension MIBSFramework.HTTPHeaders : Swift.Collection {
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public subscript(position: Swift.Int) -> MIBSFramework.HTTPHeader {
    get
  }
  public func index(after i: Swift.Int) -> Swift.Int
  public typealias Element = MIBSFramework.HTTPHeader
  public typealias Index = Swift.Int
  public typealias Indices = Swift.DefaultIndices<MIBSFramework.HTTPHeaders>
  public typealias Iterator = Swift.IndexingIterator<[MIBSFramework.HTTPHeader]>
  public typealias SubSequence = Swift.Slice<MIBSFramework.HTTPHeaders>
}
extension MIBSFramework.HTTPHeaders : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct HTTPHeader : Swift.Hashable {
  public let name: Swift.String
  public let value: Swift.String
  public init(name: Swift.String, value: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: MIBSFramework.HTTPHeader, b: MIBSFramework.HTTPHeader) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension MIBSFramework.HTTPHeader : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension MIBSFramework.HTTPHeader {
  public static func accept(_ value: Swift.String) -> MIBSFramework.HTTPHeader
  public static func acceptCharset(_ value: Swift.String) -> MIBSFramework.HTTPHeader
  public static func acceptLanguage(_ value: Swift.String) -> MIBSFramework.HTTPHeader
  public static func acceptEncoding(_ value: Swift.String) -> MIBSFramework.HTTPHeader
  public static func authorization(username: Swift.String, password: Swift.String) -> MIBSFramework.HTTPHeader
  public static func authorization(bearerToken: Swift.String) -> MIBSFramework.HTTPHeader
  public static func authorization(_ value: Swift.String) -> MIBSFramework.HTTPHeader
  public static func contentDisposition(_ value: Swift.String) -> MIBSFramework.HTTPHeader
  public static func contentType(_ value: Swift.String) -> MIBSFramework.HTTPHeader
  public static func userAgent(_ value: Swift.String) -> MIBSFramework.HTTPHeader
}
extension MIBSFramework.HTTPHeaders {
  public static let `default`: MIBSFramework.HTTPHeaders
}
extension MIBSFramework.HTTPHeader {
  public static let defaultAcceptEncoding: MIBSFramework.HTTPHeader
  public static let defaultAcceptLanguage: MIBSFramework.HTTPHeader
  public static let defaultUserAgent: MIBSFramework.HTTPHeader
}
extension Foundation.URLRequest {
  public var headers: MIBSFramework.HTTPHeaders {
    get
    set
  }
}
extension Foundation.HTTPURLResponse {
  public var headers: MIBSFramework.HTTPHeaders {
    get
  }
}
extension Foundation.URLSessionConfiguration {
  public var headers: MIBSFramework.HTTPHeaders {
    get
    set
  }
}
public enum AFError : Swift.Error {
  public enum MultipartEncodingFailureReason {
    case bodyPartURLInvalid(url: Foundation.URL)
    case bodyPartFilenameInvalid(in: Foundation.URL)
    case bodyPartFileNotReachable(at: Foundation.URL)
    case bodyPartFileNotReachableWithError(atURL: Foundation.URL, error: Swift.Error)
    case bodyPartFileIsDirectory(at: Foundation.URL)
    case bodyPartFileSizeNotAvailable(at: Foundation.URL)
    case bodyPartFileSizeQueryFailedWithError(forURL: Foundation.URL, error: Swift.Error)
    case bodyPartInputStreamCreationFailed(for: Foundation.URL)
    case outputStreamCreationFailed(for: Foundation.URL)
    case outputStreamFileAlreadyExists(at: Foundation.URL)
    case outputStreamURLInvalid(url: Foundation.URL)
    case outputStreamWriteFailed(error: Swift.Error)
    case inputStreamReadFailed(error: Swift.Error)
  }
  public struct UnexpectedInputStreamLength : Swift.Error {
    public var bytesExpected: Swift.UInt64
    public var bytesRead: Swift.UInt64
  }
  public enum ParameterEncodingFailureReason {
    case missingURL
    case jsonEncodingFailed(error: Swift.Error)
    case customEncodingFailed(error: Swift.Error)
  }
  public enum ParameterEncoderFailureReason {
    public enum RequiredComponent {
      case url
      case httpMethod(rawValue: Swift.String)
    }
    case missingRequiredComponent(MIBSFramework.AFError.ParameterEncoderFailureReason.RequiredComponent)
    case encoderFailed(error: Swift.Error)
  }
  public enum ResponseValidationFailureReason {
    case dataFileNil
    case dataFileReadFailed(at: Foundation.URL)
    case missingContentType(acceptableContentTypes: [Swift.String])
    case unacceptableContentType(acceptableContentTypes: [Swift.String], responseContentType: Swift.String)
    case unacceptableStatusCode(code: Swift.Int)
    case customValidationFailed(error: Swift.Error)
  }
  public enum ResponseSerializationFailureReason {
    case inputDataNilOrZeroLength
    case inputFileNil
    case inputFileReadFailed(at: Foundation.URL)
    case stringSerializationFailed(encoding: Swift.String.Encoding)
    case jsonSerializationFailed(error: Swift.Error)
    case decodingFailed(error: Swift.Error)
    case customSerializationFailed(error: Swift.Error)
    case invalidEmptyResponse(type: Swift.String)
  }
  public enum ServerTrustFailureReason {
    public struct Output {
      public let host: Swift.String
      public let trust: Security.SecTrust
      public let status: Darwin.OSStatus
      public let result: Security.SecTrustResultType
    }
    case noRequiredEvaluator(host: Swift.String)
    case noCertificatesFound
    case noPublicKeysFound
    case policyApplicationFailed(trust: Security.SecTrust, policy: Security.SecPolicy, status: Darwin.OSStatus)
    case settingAnchorCertificatesFailed(status: Darwin.OSStatus, certificates: [Security.SecCertificate])
    case revocationPolicyCreationFailed
    case trustEvaluationFailed(error: Swift.Error?)
    case defaultEvaluationFailed(output: MIBSFramework.AFError.ServerTrustFailureReason.Output)
    case hostValidationFailed(output: MIBSFramework.AFError.ServerTrustFailureReason.Output)
    case revocationCheckFailed(output: MIBSFramework.AFError.ServerTrustFailureReason.Output, options: MIBSFramework.RevocationTrustEvaluator.Options)
    case certificatePinningFailed(host: Swift.String, trust: Security.SecTrust, pinnedCertificates: [Security.SecCertificate], serverCertificates: [Security.SecCertificate])
    case publicKeyPinningFailed(host: Swift.String, trust: Security.SecTrust, pinnedKeys: [Security.SecKey], serverKeys: [Security.SecKey])
    case customEvaluationFailed(error: Swift.Error)
  }
  public enum URLRequestValidationFailureReason {
    case bodyDataInGETRequest(Foundation.Data)
  }
  case createUploadableFailed(error: Swift.Error)
  case createURLRequestFailed(error: Swift.Error)
  case downloadedFileMoveFailed(error: Swift.Error, source: Foundation.URL, destination: Foundation.URL)
  case explicitlyCancelled
  case invalidURL(url: MIBSFramework.URLConvertible)
  case multipartEncodingFailed(reason: MIBSFramework.AFError.MultipartEncodingFailureReason)
  case parameterEncodingFailed(reason: MIBSFramework.AFError.ParameterEncodingFailureReason)
  case parameterEncoderFailed(reason: MIBSFramework.AFError.ParameterEncoderFailureReason)
  case requestAdaptationFailed(error: Swift.Error)
  case requestRetryFailed(retryError: Swift.Error, originalError: Swift.Error)
  case responseValidationFailed(reason: MIBSFramework.AFError.ResponseValidationFailureReason)
  case responseSerializationFailed(reason: MIBSFramework.AFError.ResponseSerializationFailureReason)
  case serverTrustEvaluationFailed(reason: MIBSFramework.AFError.ServerTrustFailureReason)
  case sessionDeinitialized
  case sessionInvalidated(error: Swift.Error?)
  case sessionTaskFailed(error: Swift.Error)
  case urlRequestValidationFailed(reason: MIBSFramework.AFError.URLRequestValidationFailureReason)
}
extension Swift.Error {
  public var asAFError: MIBSFramework.AFError? {
    get
  }
  public func asAFError(orFailWith message: @autoclosure () -> Swift.String, file: Swift.StaticString = #file, line: Swift.UInt = #line) -> MIBSFramework.AFError
}
extension MIBSFramework.AFError {
  public var isSessionDeinitializedError: Swift.Bool {
    get
  }
  public var isSessionInvalidatedError: Swift.Bool {
    get
  }
  public var isExplicitlyCancelledError: Swift.Bool {
    get
  }
  public var isInvalidURLError: Swift.Bool {
    get
  }
  public var isParameterEncodingError: Swift.Bool {
    get
  }
  public var isParameterEncoderError: Swift.Bool {
    get
  }
  public var isMultipartEncodingError: Swift.Bool {
    get
  }
  public var isRequestAdaptationError: Swift.Bool {
    get
  }
  public var isResponseValidationError: Swift.Bool {
    get
  }
  public var isResponseSerializationError: Swift.Bool {
    get
  }
  public var isServerTrustEvaluationError: Swift.Bool {
    get
  }
  public var isRequestRetryError: Swift.Bool {
    get
  }
  public var isCreateUploadableError: Swift.Bool {
    get
  }
  public var isCreateURLRequestError: Swift.Bool {
    get
  }
  public var isDownloadedFileMoveError: Swift.Bool {
    get
  }
  public var isSessionTaskError: Swift.Bool {
    get
  }
}
extension MIBSFramework.AFError {
  public var urlConvertible: MIBSFramework.URLConvertible? {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public var underlyingError: Swift.Error? {
    get
  }
  public var acceptableContentTypes: [Swift.String]? {
    get
  }
  public var responseContentType: Swift.String? {
    get
  }
  public var responseCode: Swift.Int? {
    get
  }
  public var failedStringEncoding: Swift.String.Encoding? {
    get
  }
  public var sourceURL: Foundation.URL? {
    get
  }
  public var destinationURL: Foundation.URL? {
    get
  }
  public var downloadResumeData: Foundation.Data? {
    get
  }
}
extension MIBSFramework.AFError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOSApplicationExtension, unavailable)
@objc @_Concurrency.MainActor(unsafe) open class IQTitleBarButtonItem : MIBSFramework.IQBarButtonItem {
  @objc @_Concurrency.MainActor(unsafe) open var titleFont: UIKit.UIFont? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var title: Swift.String? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) open var titleColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) open var selectableTitleColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override open var invocation: MIBSFramework.IQInvocation? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) convenience public init(title: Swift.String?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
public protocol AnimationImageProvider {
  func imageForAsset(asset: MIBSFramework.ImageAsset) -> CoreGraphics.CGImage?
}
@objc @_Concurrency.MainActor(unsafe) open class AnimatedControl : UIKit.UIControl {
  @_Concurrency.MainActor(unsafe) public init(animation: MIBSFramework.Animation, configuration: MIBSFramework.LottieConfiguration = .shared)
  @_Concurrency.MainActor(unsafe) @objc dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var isEnabled: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var isSelected: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var isHighlighted: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func beginTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func continueTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func cancelTracking(with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) open func animationDidSet()
  @_Concurrency.MainActor(unsafe) final public let animationView: MIBSFramework.AnimationView
  @_Concurrency.MainActor(unsafe) public var animation: MIBSFramework.Animation? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var animationSpeed: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public func setLayer(named: Swift.String, forState: UIKit.UIControl.State)
  @_Concurrency.MainActor(unsafe) public func setValueProvider(_ valueProvider: MIBSFramework.AnyValueProvider, keypath: MIBSFramework.AnimationKeypath)
  @objc deinit
}
public protocol URLConvertible {
  func asURL() throws -> Foundation.URL
}
extension Swift.String : MIBSFramework.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
extension Foundation.URL : MIBSFramework.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
extension Foundation.URLComponents : MIBSFramework.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
public protocol URLRequestConvertible {
  func asURLRequest() throws -> Foundation.URLRequest
}
extension MIBSFramework.URLRequestConvertible {
  public var urlRequest: Foundation.URLRequest? {
    get
  }
}
extension Foundation.URLRequest : MIBSFramework.URLRequestConvertible {
  public func asURLRequest() throws -> Foundation.URLRequest
}
extension Foundation.URLRequest {
  public init(url: MIBSFramework.URLConvertible, method: MIBSFramework.HTTPMethod, headers: MIBSFramework.HTTPHeaders? = nil) throws
}
extension Foundation.URLRequest {
  public var method: MIBSFramework.HTTPMethod? {
    get
    set
  }
  public func validate() throws
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class AnimatedSwitch : MIBSFramework.AnimatedControl {
  @_Concurrency.MainActor(unsafe) override public init(animation: MIBSFramework.Animation, configuration: MIBSFramework.LottieConfiguration = .shared)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) override open func animationDidSet()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  public enum CancelBehavior {
    case reverse
    case none
    public static func == (a: MIBSFramework.AnimatedSwitch.CancelBehavior, b: MIBSFramework.AnimatedSwitch.CancelBehavior) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor(unsafe) public var cancelBehavior: MIBSFramework.AnimatedSwitch.CancelBehavior
  @_Concurrency.MainActor(unsafe) public var animateUpdateWhenChangingAnimation: Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var accessibilityTraits: UIKit.UIAccessibilityTraits {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) public var isOn: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public func setIsOn(_ isOn: Swift.Bool, animated: Swift.Bool, shouldFireHaptics: Swift.Bool = true)
  @_Concurrency.MainActor(unsafe) public func setProgressForState(fromProgress: MIBSFramework.AnimationProgressTime, toProgress: MIBSFramework.AnimationProgressTime, forOnState: Swift.Bool)
  @objc deinit
}
open class TransformOf<ObjectType, JSONType> : MIBSFramework.TransformType {
  public typealias Object = ObjectType
  public typealias JSON = JSONType
  public init(fromJSON: @escaping (JSONType?) -> ObjectType?, toJSON: @escaping (ObjectType?) -> JSONType?)
  open func transformFromJSON(_ value: Any?) -> ObjectType?
  open func transformToJSON(_ value: ObjectType?) -> JSONType?
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @IBDesignable @_Concurrency.MainActor(unsafe) final public class YPDrawSignatureView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) weak final public var delegate: MIBSFramework.YPSignatureDelegate?
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) final public var strokeWidth: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) final public var strokeColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @available(*, deprecated, renamed: "backgroundColor")
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) final public var signatureBackgroundColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) final public var doesContainSignature: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc override final public func draw(_ rect: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesMoved(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override final public func gestureRecognizerShouldBegin(_ gestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) final public func clear()
  @_Concurrency.MainActor(unsafe) final public func getSignature(scale: CoreFoundation.CGFloat = 1) -> UIKit.UIImage?
  @_Concurrency.MainActor(unsafe) final public func getCroppedSignature(scale: CoreFoundation.CGFloat = 1) -> UIKit.UIImage?
  @_Concurrency.MainActor(unsafe) final public func getPDFSignature() -> Foundation.Data
  @objc deinit
}
@objc public protocol YPSignatureDelegate {
  @objc func didStart(_ view: MIBSFramework.YPDrawSignatureView)
  @objc func didFinish(_ view: MIBSFramework.YPDrawSignatureView)
}
public struct DictionaryTransform<Key, Value> : MIBSFramework.TransformType where Key : Swift.Hashable, Key : Swift.RawRepresentable, Value : MIBSFramework.Mappable, Key.RawValue == Swift.String {
  public init()
  public func transformFromJSON(_ value: Any?) -> [Key : Value]?
  public func transformToJSON(_ value: [Key : Value]?) -> Any?
  public typealias JSON = Any
  public typealias Object = [Key : Value]
}
@_hasMissingDesignatedInitializers open class LightboxImage {
  open var image: UIKit.UIImage? {
    get
  }
  open var imageURL: Foundation.URL? {
    get
  }
  open var videoURL: Foundation.URL? {
    get
  }
  open var imageClosure: (() -> UIKit.UIImage)? {
    get
  }
  open var text: Swift.String
  public init(image: UIKit.UIImage, text: Swift.String = "", videoURL: Foundation.URL? = nil)
  public init(imageURL: Foundation.URL, text: Swift.String = "", videoURL: Foundation.URL? = nil)
  public init(imageClosure: @escaping () -> UIKit.UIImage, text: Swift.String = "", videoURL: Foundation.URL? = nil)
  open func addImageTo(_ imageView: MIBSFramework.SDAnimatedImageView, completion: ((UIKit.UIImage?) -> Swift.Void)? = nil)
  @objc deinit
}
open class PlaceholderTextFormatter : MIBSFramework.TextFormatter, MIBSFramework.TextUnformatter {
  final public let textPattern: Swift.String
  final public let patternSymbol: Swift.Character
  public init(textPattern: Swift.String, patternSymbol: Swift.Character = "#")
  open func format(_ unformattedText: Swift.String?) -> Swift.String?
  open func unformat(_ formattedText: Swift.String?) -> Swift.String?
  @objc deinit
}
@available(iOSApplicationExtension, unavailable)
extension MIBSFramework.IQKeyboardManager {
  @objc final public var keyboardShowing: Swift.Bool {
    @objc get
  }
  @objc final public var keyboardFrame: CoreFoundation.CGRect {
    @objc get
  }
}
public protocol VideoCaptureDelegate : AnyObject {
  func videoCapture(_ capture: MIBSFramework.VideoCapture, didCaptureVideoFrame: CoreVideo.CVPixelBuffer?, timestamp: CoreMedia.CMTime)
}
@objc @_inheritsConvenienceInitializers public class VideoCapture : ObjectiveC.NSObject {
  public var previewLayer: AVFoundation.AVCaptureVideoPreviewLayer?
  weak public var delegate: MIBSFramework.VideoCaptureDelegate?
  public var fps: Swift.Int
  public func setUp(sessionPreset: AVFoundation.AVCaptureSession.Preset = .vga640x480, completion: @escaping (Swift.Bool) -> Swift.Void)
  public func start()
  public func stop()
  @objc override dynamic public init()
  @objc deinit
}
extension MIBSFramework.VideoCapture : AVFoundation.AVCaptureVideoDataOutputSampleBufferDelegate {
  @objc dynamic public func captureOutput(_ output: AVFoundation.AVCaptureOutput, didOutput sampleBuffer: CoreMedia.CMSampleBuffer, from connection: AVFoundation.AVCaptureConnection)
  @objc dynamic public func captureOutput(_ output: AVFoundation.AVCaptureOutput, didDrop sampleBuffer: CoreMedia.CMSampleBuffer, from connection: AVFoundation.AVCaptureConnection)
}
@_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@objc @_Concurrency.MainActor(unsafe) open class IQTextView : UIKit.UITextView {
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect, textContainer: UIKit.NSTextContainer?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func awakeFromNib()
  @objc deinit
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var placeholderTextColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var placeholder: Swift.String? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) open var attributedPlaceholder: Foundation.NSAttributedString? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var text: Swift.String! {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var attributedText: Foundation.NSAttributedString! {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var font: UIKit.UIFont? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var textAlignment: UIKit.NSTextAlignment {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override weak dynamic open var delegate: UIKit.UITextViewDelegate? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
}
open class URLTransform : MIBSFramework.TransformType {
  public typealias Object = Foundation.URL
  public typealias JSON = Swift.String
  public init(shouldEncodeURLString: Swift.Bool = false, allowedCharacterSet: Foundation.CharacterSet = .urlQueryAllowed)
  open func transformFromJSON(_ value: Any?) -> Foundation.URL?
  open func transformToJSON(_ value: Foundation.URL?) -> Swift.String?
  @objc deinit
}
@available(iOSApplicationExtension, unavailable)
@objc extension UIKit.UIViewController {
  @objc @_Concurrency.MainActor(unsafe) dynamic open func parentIQContainerViewController() -> UIKit.UIViewController?
  @objc @available(*, deprecated, message: "Due to change in core-logic of handling distance between textField and keyboard distance, this layout contraint tweak is no longer needed and things will just work out of the box regardless of constraint pinned with safeArea/layoutGuide/superview.")
  @IBOutlet @_Concurrency.MainActor(unsafe) dynamic public var IQLayoutGuideConstraint: UIKit.NSLayoutConstraint? {
    @objc get
    @objc set(newValue)
  }
}
@available(iOSApplicationExtension, unavailable)
@objc final public class IQBarButtonItemConfiguration : ObjectiveC.NSObject {
  @objc public init(barButtonSystemItem: UIKit.UIBarButtonItem.SystemItem, action: ObjectiveC.Selector)
  @objc public init(image: UIKit.UIImage, action: ObjectiveC.Selector)
  @objc public init(title: Swift.String, action: ObjectiveC.Selector)
  final public let barButtonSystemItem: UIKit.UIBarButtonItem.SystemItem?
  @objc final public let image: UIKit.UIImage?
  @objc final public let title: Swift.String?
  @objc final public let action: ObjectiveC.Selector?
  @objc deinit
}
@available(iOSApplicationExtension, unavailable)
@objc extension UIKit.UIImage {
  @objc public static func keyboardLeftImage() -> UIKit.UIImage?
  @objc public static func keyboardRightImage() -> UIKit.UIImage?
  @objc public static func keyboardUpImage() -> UIKit.UIImage?
  @objc public static func keyboardDownImage() -> UIKit.UIImage?
  @objc public static func keyboardPreviousImage() -> UIKit.UIImage?
  @objc public static func keyboardNextImage() -> UIKit.UIImage?
}
@available(iOSApplicationExtension, unavailable)
@objc extension UIKit.UIView {
  @objc @_Concurrency.MainActor(unsafe) dynamic public var keyboardToolbar: MIBSFramework.IQToolbar {
    @objc get
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public var shouldHideToolbarPlaceholder: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public var toolbarPlaceholder: Swift.String? {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public var drawingToolbarPlaceholder: Swift.String? {
    @objc get
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addKeyboardToolbarWithTarget(target: Swift.AnyObject?, titleText: Swift.String?, rightBarButtonConfiguration: MIBSFramework.IQBarButtonItemConfiguration?, previousBarButtonConfiguration: MIBSFramework.IQBarButtonItemConfiguration? = nil, nextBarButtonConfiguration: MIBSFramework.IQBarButtonItemConfiguration? = nil)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addDoneOnKeyboardWithTarget(_ target: Swift.AnyObject?, action: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addDoneOnKeyboardWithTarget(_ target: Swift.AnyObject?, action: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addRightButtonOnKeyboardWithImage(_ image: UIKit.UIImage, target: Swift.AnyObject?, action: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addRightButtonOnKeyboardWithImage(_ image: UIKit.UIImage, target: Swift.AnyObject?, action: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addRightButtonOnKeyboardWithText(_ text: Swift.String, target: Swift.AnyObject?, action: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addRightButtonOnKeyboardWithText(_ text: Swift.String, target: Swift.AnyObject?, action: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addCancelDoneOnKeyboardWithTarget(_ target: Swift.AnyObject?, cancelAction: ObjectiveC.Selector, doneAction: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addRightLeftOnKeyboardWithTarget(_ target: Swift.AnyObject?, leftButtonTitle: Swift.String, rightButtonTitle: Swift.String, leftButtonAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addRightLeftOnKeyboardWithTarget(_ target: Swift.AnyObject?, leftButtonImage: UIKit.UIImage, rightButtonImage: UIKit.UIImage, leftButtonAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addCancelDoneOnKeyboardWithTarget(_ target: Swift.AnyObject?, cancelAction: ObjectiveC.Selector, doneAction: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addRightLeftOnKeyboardWithTarget(_ target: Swift.AnyObject?, leftButtonTitle: Swift.String, rightButtonTitle: Swift.String, leftButtonAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addRightLeftOnKeyboardWithTarget(_ target: Swift.AnyObject?, leftButtonImage: UIKit.UIImage, rightButtonImage: UIKit.UIImage, leftButtonAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addPreviousNextDoneOnKeyboardWithTarget(_ target: Swift.AnyObject?, previousAction: ObjectiveC.Selector, nextAction: ObjectiveC.Selector, doneAction: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addPreviousNextRightOnKeyboardWithTarget(_ target: Swift.AnyObject?, rightButtonImage: UIKit.UIImage, previousAction: ObjectiveC.Selector, nextAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addPreviousNextRightOnKeyboardWithTarget(_ target: Swift.AnyObject?, rightButtonTitle: Swift.String, previousAction: ObjectiveC.Selector, nextAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addPreviousNextDoneOnKeyboardWithTarget(_ target: Swift.AnyObject?, previousAction: ObjectiveC.Selector, nextAction: ObjectiveC.Selector, doneAction: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addPreviousNextRightOnKeyboardWithTarget(_ target: Swift.AnyObject?, rightButtonImage: UIKit.UIImage, previousAction: ObjectiveC.Selector, nextAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addPreviousNextRightOnKeyboardWithTarget(_ target: Swift.AnyObject?, rightButtonTitle: Swift.String, previousAction: ObjectiveC.Selector, nextAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, titleText: Swift.String?)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class AnimatedButton : MIBSFramework.AnimatedControl {
  @_Concurrency.MainActor(unsafe) override public init(animation: MIBSFramework.Animation, configuration: MIBSFramework.LottieConfiguration = .shared)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func beginTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var accessibilityTraits: UIKit.UIAccessibilityTraits {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) public func setPlayRange(fromProgress: MIBSFramework.AnimationProgressTime, toProgress: MIBSFramework.AnimationProgressTime, event: UIKit.UIControl.Event)
  @_Concurrency.MainActor(unsafe) public func setPlayRange(fromMarker fromName: Swift.String, toMarker toName: Swift.String, event: UIKit.UIControl.Event)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc @_Concurrency.MainActor(unsafe) public class CardDetectionViewController : MIBSFramework.BaseCardDetectionViewController {
  @objc @_Concurrency.MainActor(unsafe) weak public var delegate: MIBSFramework.CardDetectionViewControllerDelegate?
  @objc @_Concurrency.MainActor(unsafe) public var settings: MIBSFramework.CardDetectionSettings
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) public func hideLbl()
  @objc deinit
}
public protocol ParameterEncoder {
  func encode<Parameters>(_ parameters: Parameters?, into request: Foundation.URLRequest) throws -> Foundation.URLRequest where Parameters : Swift.Encodable
}
open class JSONParameterEncoder : MIBSFramework.ParameterEncoder {
  public static var `default`: MIBSFramework.JSONParameterEncoder {
    get
  }
  public static var prettyPrinted: MIBSFramework.JSONParameterEncoder {
    get
  }
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public static var sortedKeys: MIBSFramework.JSONParameterEncoder {
    get
  }
  final public let encoder: Foundation.JSONEncoder
  public init(encoder: Foundation.JSONEncoder = JSONEncoder())
  open func encode<Parameters>(_ parameters: Parameters?, into request: Foundation.URLRequest) throws -> Foundation.URLRequest where Parameters : Swift.Encodable
  @objc deinit
}
extension MIBSFramework.ParameterEncoder where Self == MIBSFramework.JSONParameterEncoder {
  public static var json: MIBSFramework.JSONParameterEncoder {
    get
  }
  public static func json(encoder: Foundation.JSONEncoder = JSONEncoder()) -> MIBSFramework.JSONParameterEncoder
}
open class URLEncodedFormParameterEncoder : MIBSFramework.ParameterEncoder {
  public enum Destination {
    case methodDependent
    case queryString
    case httpBody
    public static func == (a: MIBSFramework.URLEncodedFormParameterEncoder.Destination, b: MIBSFramework.URLEncodedFormParameterEncoder.Destination) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var `default`: MIBSFramework.URLEncodedFormParameterEncoder {
    get
  }
  final public let encoder: MIBSFramework.URLEncodedFormEncoder
  final public let destination: MIBSFramework.URLEncodedFormParameterEncoder.Destination
  public init(encoder: MIBSFramework.URLEncodedFormEncoder = URLEncodedFormEncoder(), destination: MIBSFramework.URLEncodedFormParameterEncoder.Destination = .methodDependent)
  open func encode<Parameters>(_ parameters: Parameters?, into request: Foundation.URLRequest) throws -> Foundation.URLRequest where Parameters : Swift.Encodable
  @objc deinit
}
extension MIBSFramework.ParameterEncoder where Self == MIBSFramework.URLEncodedFormParameterEncoder {
  public static var urlEncodedForm: MIBSFramework.URLEncodedFormParameterEncoder {
    get
  }
  public static func urlEncodedForm(encoder: MIBSFramework.URLEncodedFormEncoder = URLEncodedFormEncoder(), destination: MIBSFramework.URLEncodedFormParameterEncoder.Destination = .methodDependent) -> MIBSFramework.URLEncodedFormParameterEncoder
}
open class MultipartFormData {
  public static let encodingMemoryThreshold: Swift.UInt64
  open var contentType: Swift.String {
    get
    set
  }
  public var contentLength: Swift.UInt64 {
    get
  }
  final public let boundary: Swift.String
  public init(fileManager: Foundation.FileManager = .default, boundary: Swift.String? = nil)
  public func append(_ data: Foundation.Data, withName name: Swift.String, fileName: Swift.String? = nil, mimeType: Swift.String? = nil)
  public func append(_ fileURL: Foundation.URL, withName name: Swift.String)
  public func append(_ fileURL: Foundation.URL, withName name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ stream: Foundation.InputStream, withLength length: Swift.UInt64, name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ stream: Foundation.InputStream, withLength length: Swift.UInt64, headers: MIBSFramework.HTTPHeaders)
  public func encode() throws -> Foundation.Data
  public func writeEncodedData(to fileURL: Foundation.URL) throws
  @objc deinit
}
public protocol AnimationFontProvider {
  func fontFor(family: Swift.String, size: CoreFoundation.CGFloat) -> CoreText.CTFont?
}
final public class DefaultFontProvider : MIBSFramework.AnimationFontProvider {
  public init()
  final public func fontFor(family: Swift.String, size: CoreFoundation.CGFloat) -> CoreText.CTFont?
  @objc deinit
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension MIBSFramework.Request {
  #if compiler(>=5.3) && $RethrowsProtocol
  public func uploadProgress(bufferingPolicy: MIBSFramework.StreamOf<Foundation.Progress>.BufferingPolicy = .unbounded) -> MIBSFramework.StreamOf<Foundation.Progress>
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  public func downloadProgress(bufferingPolicy: MIBSFramework.StreamOf<Foundation.Progress>.BufferingPolicy = .unbounded) -> MIBSFramework.StreamOf<Foundation.Progress>
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  public func urlRequests(bufferingPolicy: MIBSFramework.StreamOf<Foundation.URLRequest>.BufferingPolicy = .unbounded) -> MIBSFramework.StreamOf<Foundation.URLRequest>
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  public func urlSessionTasks(bufferingPolicy: MIBSFramework.StreamOf<Foundation.URLSessionTask>.BufferingPolicy = .unbounded) -> MIBSFramework.StreamOf<Foundation.URLSessionTask>
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  public func cURLDescriptions(bufferingPolicy: MIBSFramework.StreamOf<Swift.String>.BufferingPolicy = .unbounded) -> MIBSFramework.StreamOf<Swift.String>
  #endif
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct DataTask<Value> {
  #if compiler(>=5.3) && $EffectfulProp
  public var response: MIBSFramework.DataResponse<Value, MIBSFramework.AFError> {
    get async
  }
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  public var result: Swift.Result<Value, MIBSFramework.AFError> {
    get async
  }
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  public var value: Value {
    get async throws
  }
  #endif
  public func cancel()
  public func resume()
  public func suspend()
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension MIBSFramework.DataRequest {
  public func serializingData(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false, dataPreprocessor: MIBSFramework.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> MIBSFramework.DataTask<Foundation.Data>
  public func serializingDecodable<Value>(_ type: Value.Type = Value.self, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false, dataPreprocessor: MIBSFramework.DataPreprocessor = DecodableResponseSerializer<Value>.defaultDataPreprocessor, decoder: MIBSFramework.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<Value>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod> = DecodableResponseSerializer<Value>.defaultEmptyRequestMethods) -> MIBSFramework.DataTask<Value> where Value : Swift.Decodable
  public func serializingString(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false, dataPreprocessor: MIBSFramework.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> MIBSFramework.DataTask<Swift.String>
  public func serializingResponse<Serializer>(using serializer: Serializer, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false) -> MIBSFramework.DataTask<Serializer.SerializedObject> where Serializer : MIBSFramework.ResponseSerializer
  public func serializingResponse<Serializer>(using serializer: Serializer, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false) -> MIBSFramework.DataTask<Serializer.SerializedObject> where Serializer : MIBSFramework.DataResponseSerializerProtocol
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct DownloadTask<Value> {
  #if compiler(>=5.3) && $EffectfulProp
  public var response: MIBSFramework.DownloadResponse<Value, MIBSFramework.AFError> {
    get async
  }
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  public var result: Swift.Result<Value, MIBSFramework.AFError> {
    get async
  }
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  public var value: Value {
    get async throws
  }
  #endif
  public func cancel()
  public func resume()
  public func suspend()
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension MIBSFramework.DownloadRequest {
  public func serializingData(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false, dataPreprocessor: MIBSFramework.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> MIBSFramework.DownloadTask<Foundation.Data>
  public func serializingDecodable<Value>(_ type: Value.Type = Value.self, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false, dataPreprocessor: MIBSFramework.DataPreprocessor = DecodableResponseSerializer<Value>.defaultDataPreprocessor, decoder: MIBSFramework.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<Value>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod> = DecodableResponseSerializer<Value>.defaultEmptyRequestMethods) -> MIBSFramework.DownloadTask<Value> where Value : Swift.Decodable
  public func serializingDownloadedFileURL(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false) -> MIBSFramework.DownloadTask<Foundation.URL>
  public func serializingString(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false, dataPreprocessor: MIBSFramework.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> MIBSFramework.DownloadTask<Swift.String>
  public func serializingDownload<Serializer>(using serializer: Serializer, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false) -> MIBSFramework.DownloadTask<Serializer.SerializedObject> where Serializer : MIBSFramework.ResponseSerializer
  public func serializingDownload<Serializer>(using serializer: Serializer, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false) -> MIBSFramework.DownloadTask<Serializer.SerializedObject> where Serializer : MIBSFramework.DownloadResponseSerializerProtocol
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct DataStreamTask {
  #if compiler(>=5.3) && $RethrowsProtocol
  public typealias Stream<Success, Failure> = MIBSFramework.StreamOf<MIBSFramework.DataStreamRequest.Stream<Success, Failure>> where Failure : Swift.Error
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  public func streamingData(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = true, bufferingPolicy: MIBSFramework.DataStreamTask.Stream<Foundation.Data, Swift.Never>.BufferingPolicy = .unbounded) -> MIBSFramework.DataStreamTask.Stream<Foundation.Data, Swift.Never>
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  public func streamingStrings(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = true, bufferingPolicy: MIBSFramework.DataStreamTask.Stream<Swift.String, Swift.Never>.BufferingPolicy = .unbounded) -> MIBSFramework.DataStreamTask.Stream<Swift.String, Swift.Never>
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  public func streamingDecodables<T>(_ type: T.Type = T.self, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = true, bufferingPolicy: MIBSFramework.DataStreamTask.Stream<T, MIBSFramework.AFError>.BufferingPolicy = .unbounded) -> MIBSFramework.DataStreamTask.Stream<T, MIBSFramework.AFError> where T : Swift.Decodable
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  public func streamingResponses<Serializer>(serializedUsing serializer: Serializer, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = true, bufferingPolicy: MIBSFramework.DataStreamTask.Stream<Serializer.SerializedObject, MIBSFramework.AFError>.BufferingPolicy = .unbounded) -> MIBSFramework.DataStreamTask.Stream<Serializer.SerializedObject, MIBSFramework.AFError> where Serializer : MIBSFramework.DataStreamSerializer
  #endif
  public func cancel()
  public func resume()
  public func suspend()
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension MIBSFramework.DataStreamRequest {
  final public func streamTask() -> MIBSFramework.DataStreamTask
}
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct StreamOf<Element> : _Concurrency.AsyncSequence {
  public typealias AsyncIterator = MIBSFramework.StreamOf<Element>.Iterator
  public typealias BufferingPolicy = _Concurrency.AsyncStream<Element>.Continuation.BufferingPolicy
  public func makeAsyncIterator() -> MIBSFramework.StreamOf<Element>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    #if compiler(>=5.3) && $AsyncAwait
    public mutating func next() async -> Element?
    #endif
  }
}
#endif
public typealias AnimationFrameTime = CoreFoundation.CGFloat
public typealias AnimationProgressTime = CoreFoundation.CGFloat
extension UIKit.UIImage {
  public enum DataUnits : Swift.String {
    case byte, kilobyte, megabyte, gigabyte
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
extension MIBSFramework.AnimationView {
  @_Concurrency.MainActor(unsafe) convenience public init(name: Swift.String, bundle: Foundation.Bundle = Bundle.main, imageProvider: MIBSFramework.AnimationImageProvider? = nil, animationCache: MIBSFramework.AnimationCacheProvider? = LRUAnimationCache.sharedCache, configuration: MIBSFramework.LottieConfiguration = .shared)
  @_Concurrency.MainActor(unsafe) convenience public init(filePath: Swift.String, imageProvider: MIBSFramework.AnimationImageProvider? = nil, animationCache: MIBSFramework.AnimationCacheProvider? = LRUAnimationCache.sharedCache, configuration: MIBSFramework.LottieConfiguration = .shared)
  @_Concurrency.MainActor(unsafe) convenience public init(url: Foundation.URL, imageProvider: MIBSFramework.AnimationImageProvider? = nil, closure: @escaping MIBSFramework.AnimationView.DownloadClosure, animationCache: MIBSFramework.AnimationCacheProvider? = LRUAnimationCache.sharedCache, configuration: MIBSFramework.LottieConfiguration = .shared)
  @_Concurrency.MainActor(unsafe) convenience public init(asset name: Swift.String, bundle: Foundation.Bundle = Bundle.main, imageProvider: MIBSFramework.AnimationImageProvider? = nil, animationCache: MIBSFramework.AnimationCacheProvider? = LRUAnimationCache.sharedCache, configuration: MIBSFramework.LottieConfiguration = .shared)
  public typealias DownloadClosure = (Swift.Error?) -> Swift.Void
}
open class NSDecimalNumberTransform : MIBSFramework.TransformType {
  public typealias Object = Foundation.NSDecimalNumber
  public typealias JSON = Swift.String
  public init()
  open func transformFromJSON(_ value: Any?) -> Foundation.NSDecimalNumber?
  open func transformToJSON(_ value: Foundation.NSDecimalNumber?) -> Swift.String?
  @objc deinit
}
@objc public protocol CardAndBarcodeDetectionViewControllerDelegate {
  @objc func cardAndBarcodeDetectionViewController(_ viewController: MIBSFramework.CardAndBarcodeDetectionViewController, didDetectCard image: CoreGraphics.CGImage, andBarcodes barcodes: [Vision.VNBarcodeObservation], withSettings settings: MIBSFramework.CardAndBarcodeDetectionSettings)
  @objc optional func cardAndBarcodeDetectionViewControllerDidCancel(_ viewController: MIBSFramework.CardAndBarcodeDetectionViewController)
  @objc optional func qualityOfImage(_ image: CoreGraphics.CGImage) -> Foundation.NSNumber?
}
public enum CoordinateSpace : Swift.Int, Swift.Codable {
  case type2d
  case type3d
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
final public class Animation : Swift.Codable {
  required public init(from decoder: Swift.Decoder) throws
  public init(dictionary: [Swift.String : Any]) throws
  final public let startFrame: MIBSFramework.AnimationFrameTime
  final public let endFrame: MIBSFramework.AnimationFrameTime
  final public let framerate: Swift.Double
  final public var markerNames: [Swift.String] {
    get
  }
  @objc deinit
  final public func encode(to encoder: Swift.Encoder) throws
}
extension UIKit.UITextView {
  @_Concurrency.MainActor(unsafe) public func hitTest(pointInGliphRange aPoint: CoreFoundation.CGPoint, event: UIKit.UIEvent?, test: (Swift.Int) -> UIKit.UIView?) -> UIKit.UIView?
  @_Concurrency.MainActor(unsafe) public func pointIsInTextRange(point aPoint: CoreFoundation.CGPoint, range: Foundation.NSRange, padding: UIKit.UIEdgeInsets) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) public func charIndexForPointInGlyphRect(point aPoint: CoreFoundation.CGPoint) -> Swift.Int?
}
extension UIKit.NSLayoutManager {
  public func characterRangeThatFits(textContainer container: UIKit.NSTextContainer) -> Foundation.NSRange
  public func boundingRectForCharacterRange(range aRange: Foundation.NSRange, inTextContainer container: UIKit.NSTextContainer) -> CoreFoundation.CGRect
}
@available(iOSApplicationExtension, unavailable)
public let kIQUseDefaultKeyboardDistance: CoreFoundation.CGFloat
@available(iOSApplicationExtension, unavailable)
@objc extension UIKit.UIView {
  @objc @_Concurrency.MainActor(unsafe) dynamic public var keyboardDistanceFromTextField: CoreFoundation.CGFloat {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public var ignoreSwitchingByNextPrevious: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public var enableMode: MIBSFramework.IQEnableMode {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public var shouldResignOnTouchOutsideMode: MIBSFramework.IQEnableMode {
    @objc get
    @objc set(newValue)
  }
}
public protocol BaseMappable {
  mutating func mapping(map: MIBSFramework.Map)
}
public protocol Mappable : MIBSFramework.BaseMappable {
  init?(map: MIBSFramework.Map)
}
public protocol StaticMappable : MIBSFramework.BaseMappable {
  static func objectForMapping(map: MIBSFramework.Map) -> MIBSFramework.BaseMappable?
}
extension MIBSFramework.Mappable {
  public init?(JSONString: Swift.String, context: MIBSFramework.MapContext? = nil)
  public init?(JSON: [Swift.String : Any], context: MIBSFramework.MapContext? = nil)
}
extension MIBSFramework.BaseMappable {
  public func toJSON() -> [Swift.String : Any]
  public func toJSONString(prettyPrint: Swift.Bool = false) -> Swift.String?
}
extension Swift.Array where Element : MIBSFramework.BaseMappable {
  public init?(JSONString: Swift.String, context: MIBSFramework.MapContext? = nil)
  public init(JSONArray: [[Swift.String : Any]], context: MIBSFramework.MapContext? = nil)
  public func toJSON() -> [[Swift.String : Any]]
  public func toJSONString(prettyPrint: Swift.Bool = false) -> Swift.String?
}
extension Swift.Set where Element : MIBSFramework.BaseMappable {
  public init?(JSONString: Swift.String, context: MIBSFramework.MapContext? = nil)
  public init?(JSONArray: [[Swift.String : Any]], context: MIBSFramework.MapContext? = nil)
  public func toJSON() -> [[Swift.String : Any]]
  public func toJSONString(prettyPrint: Swift.Bool = false) -> Swift.String?
}
public typealias AnimationOptions = UIKit.UIView.AnimationOptions
extension UIKit.UIImageView {
  public enum ImageTransition {
    case noTransition
    case crossDissolve(Foundation.TimeInterval)
    case curlDown(Foundation.TimeInterval)
    case curlUp(Foundation.TimeInterval)
    case flipFromBottom(Foundation.TimeInterval)
    case flipFromLeft(Foundation.TimeInterval)
    case flipFromRight(Foundation.TimeInterval)
    case flipFromTop(Foundation.TimeInterval)
    case custom(duration: Foundation.TimeInterval, animationOptions: UIKit.UIView.AnimationOptions, animations: (UIKit.UIImageView, MIBSFramework.Image) -> Swift.Void, completion: ((Swift.Bool) -> Swift.Void)?)
    public var duration: Foundation.TimeInterval {
      get
    }
    public var animationOptions: UIKit.UIView.AnimationOptions {
      get
    }
    public var animations: (UIKit.UIImageView, MIBSFramework.Image) -> Swift.Void {
      get
    }
    public var completion: ((Swift.Bool) -> Swift.Void)? {
      get
    }
  }
}
extension UIKit.UIImageView : MIBSFramework.AlamofireExtended {
  public typealias ExtendedType = UIKit.UIImageView
}
extension MIBSFramework.AlamofireExtension where ExtendedType : UIKit.UIImageView {
  public var imageDownloader: MIBSFramework.ImageDownloader? {
    get
    nonmutating set(downloader)
  }
  public static var sharedImageDownloader: MIBSFramework.ImageDownloader {
    get
    set
  }
  public func setImage(withURL url: Foundation.URL, cacheKey: Swift.String? = nil, placeholderImage: UIKit.UIImage? = nil, serializer: MIBSFramework.ImageResponseSerializer? = nil, filter: MIBSFramework.ImageFilter? = nil, progress: MIBSFramework.ImageDownloader.ProgressHandler? = nil, progressQueue: Dispatch.DispatchQueue = DispatchQueue.main, imageTransition: UIKit.UIImageView.ImageTransition = .noTransition, runImageTransitionIfCached: Swift.Bool = false, completion: ((MIBSFramework.AFIDataResponse<UIKit.UIImage>) -> Swift.Void)? = nil)
  public func setImage(withURLRequest urlRequest: MIBSFramework.URLRequestConvertible, cacheKey: Swift.String? = nil, placeholderImage: UIKit.UIImage? = nil, serializer: MIBSFramework.ImageResponseSerializer? = nil, filter: MIBSFramework.ImageFilter? = nil, progress: MIBSFramework.ImageDownloader.ProgressHandler? = nil, progressQueue: Dispatch.DispatchQueue = DispatchQueue.main, imageTransition: UIKit.UIImageView.ImageTransition = .noTransition, runImageTransitionIfCached: Swift.Bool = false, completion: ((MIBSFramework.AFIDataResponse<UIKit.UIImage>) -> Swift.Void)? = nil)
  public func cancelImageRequest()
  public func run(_ imageTransition: UIKit.UIImageView.ImageTransition, with image: MIBSFramework.Image)
}
extension UIKit.UIImageView {
  @available(*, deprecated, message: "Replaced by `imageView.af.imageDownloader`")
  @_Concurrency.MainActor(unsafe) public var af_imageDownloader: MIBSFramework.ImageDownloader? {
    get
    set
  }
  @available(*, deprecated, message: "Replaced by `imageView.af.sharedImageDownloader`")
  @_Concurrency.MainActor(unsafe) public class var af_sharedImageDownloader: MIBSFramework.ImageDownloader {
    get
    set
  }
  @available(*, deprecated, message: "Replaced by `imageView.af.setImage(withURL: ...)`")
  @_Concurrency.MainActor(unsafe) public func af_setImage(withURL url: Foundation.URL, cacheKey: Swift.String? = nil, placeholderImage: UIKit.UIImage? = nil, serializer: MIBSFramework.ImageResponseSerializer? = nil, filter: MIBSFramework.ImageFilter? = nil, progress: MIBSFramework.ImageDownloader.ProgressHandler? = nil, progressQueue: Dispatch.DispatchQueue = DispatchQueue.main, imageTransition: UIKit.UIImageView.ImageTransition = .noTransition, runImageTransitionIfCached: Swift.Bool = false, completion: ((MIBSFramework.AFIDataResponse<UIKit.UIImage>) -> Swift.Void)? = nil)
  @available(*, deprecated, message: "Replaced by `imageView.af.setImage(withURLRequest: ...)`")
  @_Concurrency.MainActor(unsafe) public func af_setImage(withURLRequest urlRequest: MIBSFramework.URLRequestConvertible, cacheKey: Swift.String? = nil, placeholderImage: UIKit.UIImage? = nil, serializer: MIBSFramework.ImageResponseSerializer? = nil, filter: MIBSFramework.ImageFilter? = nil, progress: MIBSFramework.ImageDownloader.ProgressHandler? = nil, progressQueue: Dispatch.DispatchQueue = DispatchQueue.main, imageTransition: UIKit.UIImageView.ImageTransition = .noTransition, runImageTransitionIfCached: Swift.Bool = false, completion: ((MIBSFramework.AFIDataResponse<UIKit.UIImage>) -> Swift.Void)? = nil)
  @available(*, deprecated, message: "Replaced by `imageView.af.cancelImageRequest()`")
  @_Concurrency.MainActor(unsafe) public func af_cancelImageRequest()
  @available(*, deprecated, message: "Replaced by `imageView.af.run(_:with:)`")
  @_Concurrency.MainActor(unsafe) public func run(_ imageTransition: UIKit.UIImageView.ImageTransition, with image: MIBSFramework.Image)
}
@available(iOSApplicationExtension, unavailable)
@objc extension UIKit.UIView {
  @objc @_Concurrency.MainActor(unsafe) dynamic public func viewContainingController() -> UIKit.UIViewController?
  @objc @_Concurrency.MainActor(unsafe) dynamic public func topMostController() -> UIKit.UIViewController?
  @objc @_Concurrency.MainActor(unsafe) dynamic public func parentContainerViewController() -> UIKit.UIViewController?
  @objc @_Concurrency.MainActor(unsafe) dynamic public func superviewOfClassType(_ classType: UIKit.UIView.Type, belowView: UIKit.UIView? = nil) -> UIKit.UIView?
}
public protocol ImageFilter {
  var filter: (MIBSFramework.Image) -> MIBSFramework.Image { get }
  var identifier: Swift.String { get }
}
extension MIBSFramework.ImageFilter {
  public var identifier: Swift.String {
    get
  }
}
public protocol Sizable {
  var size: CoreFoundation.CGSize { get }
}
extension MIBSFramework.ImageFilter where Self : MIBSFramework.Sizable {
  public var identifier: Swift.String {
    get
  }
}
public protocol Roundable {
  var radius: CoreFoundation.CGFloat { get }
}
extension MIBSFramework.ImageFilter where Self : MIBSFramework.Roundable {
  public var identifier: Swift.String {
    get
  }
}
public struct DynamicImageFilter : MIBSFramework.ImageFilter {
  public let identifier: Swift.String
  public let filter: (MIBSFramework.Image) -> MIBSFramework.Image
  public init(_ identifier: Swift.String, filter: @escaping (MIBSFramework.Image) -> MIBSFramework.Image)
}
public protocol CompositeImageFilter : MIBSFramework.ImageFilter {
  var filters: [MIBSFramework.ImageFilter] { get }
}
extension MIBSFramework.CompositeImageFilter {
  public var identifier: Swift.String {
    get
  }
  public var filter: (MIBSFramework.Image) -> MIBSFramework.Image {
    get
  }
}
public struct DynamicCompositeImageFilter : MIBSFramework.CompositeImageFilter {
  public let filters: [MIBSFramework.ImageFilter]
  public init(_ filters: [MIBSFramework.ImageFilter])
  public init(_ filters: MIBSFramework.ImageFilter...)
}
public struct ScaledToSizeFilter : MIBSFramework.ImageFilter, MIBSFramework.Sizable {
  public let size: CoreFoundation.CGSize
  public init(size: CoreFoundation.CGSize)
  public var filter: (MIBSFramework.Image) -> MIBSFramework.Image {
    get
  }
}
public struct AspectScaledToFitSizeFilter : MIBSFramework.ImageFilter, MIBSFramework.Sizable {
  public let size: CoreFoundation.CGSize
  public init(size: CoreFoundation.CGSize)
  public var filter: (MIBSFramework.Image) -> MIBSFramework.Image {
    get
  }
}
public struct AspectScaledToFillSizeFilter : MIBSFramework.ImageFilter, MIBSFramework.Sizable {
  public let size: CoreFoundation.CGSize
  public init(size: CoreFoundation.CGSize)
  public var filter: (MIBSFramework.Image) -> MIBSFramework.Image {
    get
  }
}
public struct RoundedCornersFilter : MIBSFramework.ImageFilter, MIBSFramework.Roundable {
  public let radius: CoreFoundation.CGFloat
  public let divideRadiusByImageScale: Swift.Bool
  public init(radius: CoreFoundation.CGFloat, divideRadiusByImageScale: Swift.Bool = false)
  public var filter: (MIBSFramework.Image) -> MIBSFramework.Image {
    get
  }
  public var identifier: Swift.String {
    get
  }
}
public struct CircleFilter : MIBSFramework.ImageFilter {
  public init()
  public var filter: (MIBSFramework.Image) -> MIBSFramework.Image {
    get
  }
}
public protocol CoreImageFilter : MIBSFramework.ImageFilter {
  var filterName: Swift.String { get }
  var parameters: [Swift.String : Any] { get }
}
extension MIBSFramework.ImageFilter where Self : MIBSFramework.CoreImageFilter {
  public var filter: (MIBSFramework.Image) -> MIBSFramework.Image {
    get
  }
  public var identifier: Swift.String {
    get
  }
}
public struct BlurFilter : MIBSFramework.ImageFilter, MIBSFramework.CoreImageFilter {
  public let filterName: Swift.String
  public let parameters: [Swift.String : Any]
  public init(blurRadius: Swift.UInt = 10)
}
public struct ScaledToSizeWithRoundedCornersFilter : MIBSFramework.CompositeImageFilter {
  public init(size: CoreFoundation.CGSize, radius: CoreFoundation.CGFloat, divideRadiusByImageScale: Swift.Bool = false)
  public let filters: [MIBSFramework.ImageFilter]
}
public struct AspectScaledToFillSizeWithRoundedCornersFilter : MIBSFramework.CompositeImageFilter {
  public init(size: CoreFoundation.CGSize, radius: CoreFoundation.CGFloat, divideRadiusByImageScale: Swift.Bool = false)
  public let filters: [MIBSFramework.ImageFilter]
}
public struct ScaledToSizeCircleFilter : MIBSFramework.CompositeImageFilter {
  public init(size: CoreFoundation.CGSize)
  public let filters: [MIBSFramework.ImageFilter]
}
public struct AspectScaledToFillSizeCircleFilter : MIBSFramework.CompositeImageFilter {
  public init(size: CoreFoundation.CGSize)
  public let filters: [MIBSFramework.ImageFilter]
}
public protocol ImageCache {
  func add(_ image: MIBSFramework.Image, withIdentifier identifier: Swift.String)
  func removeImage(withIdentifier identifier: Swift.String) -> Swift.Bool
  @discardableResult
  func removeAllImages() -> Swift.Bool
  func image(withIdentifier identifier: Swift.String) -> MIBSFramework.Image?
}
public protocol ImageRequestCache : MIBSFramework.ImageCache {
  func add(_ image: MIBSFramework.Image, for request: Foundation.URLRequest, withIdentifier identifier: Swift.String?)
  func removeImage(for request: Foundation.URLRequest, withIdentifier identifier: Swift.String?) -> Swift.Bool
  func image(for request: Foundation.URLRequest, withIdentifier identifier: Swift.String?) -> MIBSFramework.Image?
}
open class AutoPurgingImageCache : MIBSFramework.ImageRequestCache {
  open var memoryUsage: Swift.UInt64 {
    get
  }
  final public let memoryCapacity: Swift.UInt64
  final public let preferredMemoryUsageAfterPurge: Swift.UInt64
  public init(memoryCapacity: Swift.UInt64 = 100_000_000, preferredMemoryUsageAfterPurge: Swift.UInt64 = 60_000_000)
  @objc deinit
  open func add(_ image: MIBSFramework.Image, for request: Foundation.URLRequest, withIdentifier identifier: Swift.String? = nil)
  open func add(_ image: MIBSFramework.Image, withIdentifier identifier: Swift.String)
  @discardableResult
  open func removeImage(for request: Foundation.URLRequest, withIdentifier identifier: Swift.String?) -> Swift.Bool
  @discardableResult
  open func removeImages(matching request: Foundation.URLRequest) -> Swift.Bool
  @discardableResult
  open func removeImage(withIdentifier identifier: Swift.String) -> Swift.Bool
  @discardableResult
  @objc open func removeAllImages() -> Swift.Bool
  open func image(for request: Foundation.URLRequest, withIdentifier identifier: Swift.String? = nil) -> MIBSFramework.Image?
  open func image(withIdentifier identifier: Swift.String) -> MIBSFramework.Image?
  open func imageCacheKey(for request: Foundation.URLRequest, withIdentifier identifier: Swift.String?) -> Swift.String
}
open class DataTransform : MIBSFramework.TransformType {
  public typealias Object = Foundation.Data
  public typealias JSON = Swift.String
  public init()
  open func transformFromJSON(_ value: Any?) -> Foundation.Data?
  open func transformToJSON(_ value: Foundation.Data?) -> Swift.String?
  @objc deinit
}
public protocol RedirectHandler {
  func task(_ task: Foundation.URLSessionTask, willBeRedirectedTo request: Foundation.URLRequest, for response: Foundation.HTTPURLResponse, completion: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
public struct Redirector {
  public enum Behavior {
    case follow
    case doNotFollow
    case modify((Foundation.URLSessionTask, Foundation.URLRequest, Foundation.HTTPURLResponse) -> Foundation.URLRequest?)
  }
  public static let follow: MIBSFramework.Redirector
  public static let doNotFollow: MIBSFramework.Redirector
  public let behavior: MIBSFramework.Redirector.Behavior
  public init(behavior: MIBSFramework.Redirector.Behavior)
}
extension MIBSFramework.Redirector : MIBSFramework.RedirectHandler {
  public func task(_ task: Foundation.URLSessionTask, willBeRedirectedTo request: Foundation.URLRequest, for response: Foundation.HTTPURLResponse, completion: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
extension MIBSFramework.RedirectHandler where Self == MIBSFramework.Redirector {
  public static var follow: MIBSFramework.Redirector {
    get
  }
  public static var doNotFollow: MIBSFramework.Redirector {
    get
  }
  public static func modify(using closure: @escaping (Foundation.URLSessionTask, Foundation.URLRequest, Foundation.HTTPURLResponse) -> Foundation.URLRequest?) -> MIBSFramework.Redirector
}
public protocol AuthenticationCredential {
  var requiresRefresh: Swift.Bool { get }
}
public protocol Authenticator : AnyObject {
  associatedtype Credential : MIBSFramework.AuthenticationCredential
  func apply(_ credential: Self.Credential, to urlRequest: inout Foundation.URLRequest)
  func refresh(_ credential: Self.Credential, for session: MIBSFramework.Session, completion: @escaping (Swift.Result<Self.Credential, Swift.Error>) -> Swift.Void)
  func didRequest(_ urlRequest: Foundation.URLRequest, with response: Foundation.HTTPURLResponse, failDueToAuthenticationError error: Swift.Error) -> Swift.Bool
  func isRequest(_ urlRequest: Foundation.URLRequest, authenticatedWith credential: Self.Credential) -> Swift.Bool
}
public enum AuthenticationError : Swift.Error {
  case missingCredential
  case excessiveRefresh
  public static func == (a: MIBSFramework.AuthenticationError, b: MIBSFramework.AuthenticationError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class AuthenticationInterceptor<AuthenticatorType> : MIBSFramework.RequestInterceptor where AuthenticatorType : MIBSFramework.Authenticator {
  public typealias Credential = AuthenticatorType.Credential
  public struct RefreshWindow {
    public let interval: Foundation.TimeInterval
    public let maximumAttempts: Swift.Int
    public init(interval: Foundation.TimeInterval = 30.0, maximumAttempts: Swift.Int = 5)
  }
  public var credential: MIBSFramework.AuthenticationInterceptor<AuthenticatorType>.Credential? {
    get
    set
  }
  public init(authenticator: AuthenticatorType, credential: MIBSFramework.AuthenticationInterceptor<AuthenticatorType>.Credential? = nil, refreshWindow: MIBSFramework.AuthenticationInterceptor<AuthenticatorType>.RefreshWindow? = RefreshWindow())
  public func adapt(_ urlRequest: Foundation.URLRequest, for session: MIBSFramework.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  public func retry(_ request: MIBSFramework.Request, for session: MIBSFramework.Session, dueTo error: Swift.Error, completion: @escaping (MIBSFramework.RetryResult) -> Swift.Void)
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class BarcodeDetectionViewController : MIBSFramework.ObjectDetectionViewController {
  @objc @_Concurrency.MainActor(unsafe) weak public var delegate: MIBSFramework.BarcodeDetectionViewControllerDelegate?
  @objc @_Concurrency.MainActor(unsafe) final public let settings: MIBSFramework.BarcodeDetectionSettings
  @objc @_Concurrency.MainActor(unsafe) public init(settings: MIBSFramework.BarcodeDetectionSettings)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc override public func presentationControllerDidDismiss(_ presentationController: UIKit.UIPresentationController)
  @objc deinit
}
infix operator <- : DefaultPrecedence
infix operator >>> : DefaultPrecedence
public func <- <T>(left: inout T, right: MIBSFramework.Map)
public func >>> <T>(left: T, right: MIBSFramework.Map)
public func <- <T>(left: inout T?, right: MIBSFramework.Map)
public func >>> <T>(left: T?, right: MIBSFramework.Map)
public func <- <T>(left: inout T, right: MIBSFramework.Map) where T : MIBSFramework.BaseMappable
public func >>> <T>(left: T, right: MIBSFramework.Map) where T : MIBSFramework.BaseMappable
public func <- <T>(left: inout T?, right: MIBSFramework.Map) where T : MIBSFramework.BaseMappable
public func >>> <T>(left: T?, right: MIBSFramework.Map) where T : MIBSFramework.BaseMappable
public func <- <T>(left: inout Swift.Dictionary<Swift.String, T>, right: MIBSFramework.Map) where T : MIBSFramework.BaseMappable
public func >>> <T>(left: Swift.Dictionary<Swift.String, T>, right: MIBSFramework.Map) where T : MIBSFramework.BaseMappable
public func <- <T>(left: inout Swift.Dictionary<Swift.String, T>?, right: MIBSFramework.Map) where T : MIBSFramework.BaseMappable
public func >>> <T>(left: Swift.Dictionary<Swift.String, T>?, right: MIBSFramework.Map) where T : MIBSFramework.BaseMappable
public func <- <T>(left: inout Swift.Dictionary<Swift.String, [T]>, right: MIBSFramework.Map) where T : MIBSFramework.BaseMappable
public func >>> <T>(left: Swift.Dictionary<Swift.String, [T]>, right: MIBSFramework.Map) where T : MIBSFramework.BaseMappable
public func <- <T>(left: inout Swift.Dictionary<Swift.String, [T]>?, right: MIBSFramework.Map) where T : MIBSFramework.BaseMappable
public func >>> <T>(left: Swift.Dictionary<Swift.String, [T]>?, right: MIBSFramework.Map) where T : MIBSFramework.BaseMappable
public func <- <T>(left: inout Swift.Array<T>, right: MIBSFramework.Map) where T : MIBSFramework.BaseMappable
public func >>> <T>(left: Swift.Array<T>, right: MIBSFramework.Map) where T : MIBSFramework.BaseMappable
public func <- <T>(left: inout Swift.Array<T>?, right: MIBSFramework.Map) where T : MIBSFramework.BaseMappable
public func >>> <T>(left: Swift.Array<T>?, right: MIBSFramework.Map) where T : MIBSFramework.BaseMappable
public func <- <T>(left: inout Swift.Array<Swift.Array<T>>, right: MIBSFramework.Map) where T : MIBSFramework.BaseMappable
public func >>> <T>(left: Swift.Array<Swift.Array<T>>, right: MIBSFramework.Map) where T : MIBSFramework.BaseMappable
public func <- <T>(left: inout Swift.Array<Swift.Array<T>>?, right: MIBSFramework.Map) where T : MIBSFramework.BaseMappable
public func >>> <T>(left: Swift.Array<Swift.Array<T>>?, right: MIBSFramework.Map) where T : MIBSFramework.BaseMappable
public func <- <T>(left: inout Swift.Set<T>, right: MIBSFramework.Map) where T : MIBSFramework.BaseMappable, T : Swift.Hashable
public func >>> <T>(left: Swift.Set<T>, right: MIBSFramework.Map) where T : MIBSFramework.BaseMappable, T : Swift.Hashable
public func <- <T>(left: inout Swift.Set<T>?, right: MIBSFramework.Map) where T : MIBSFramework.BaseMappable, T : Swift.Hashable
public func >>> <T>(left: Swift.Set<T>?, right: MIBSFramework.Map) where T : MIBSFramework.BaseMappable, T : Swift.Hashable
open class HexColorTransform : MIBSFramework.TransformType {
  public typealias Object = UIKit.UIColor
  public typealias JSON = Swift.String
  public init(prefixToJSON: Swift.Bool = false, alphaToJSON: Swift.Bool = false)
  open func transformFromJSON(_ value: Any?) -> MIBSFramework.HexColorTransform.Object?
  open func transformToJSON(_ value: MIBSFramework.HexColorTransform.Object?) -> MIBSFramework.HexColorTransform.JSON?
  @objc deinit
}
public protocol TransformType {
  associatedtype Object
  associatedtype JSON
  func transformFromJSON(_ value: Any?) -> Self.Object?
  func transformToJSON(_ value: Self.Object?) -> Self.JSON?
}
@objc public protocol TorchSettings {
  @objc var torchLevel: Swift.Float { get }
}
open class CustomDateFormatTransform : MIBSFramework.DateFormatterTransform {
  public init(formatString: Swift.String)
  @objc deinit
}
@_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@objc final public class IQKeyboardReturnKeyHandler : ObjectiveC.NSObject {
  @objc weak final public var delegate: (UIKit.UITextFieldDelegate & UIKit.UITextViewDelegate)?
  @objc final public var lastTextFieldReturnKeyType: UIKit.UIReturnKeyType {
    @objc get
    @objc set
  }
  @objc override dynamic public init()
  @objc public init(controller: UIKit.UIViewController)
  @objc deinit
  @objc final public func addTextFieldView(_ view: UIKit.UIView)
  @objc final public func removeTextFieldView(_ view: UIKit.UIView)
  @objc final public func addResponderFromView(_ view: UIKit.UIView)
  @objc final public func removeResponderFromView(_ view: UIKit.UIView)
}
@available(iOSApplicationExtension, unavailable)
extension MIBSFramework.IQKeyboardReturnKeyHandler : UIKit.UITextFieldDelegate {
  @_Concurrency.MainActor(unsafe) @objc final public func textFieldShouldBeginEditing(_ textField: UIKit.UITextField) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc final public func textFieldShouldEndEditing(_ textField: UIKit.UITextField) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc final public func textFieldDidBeginEditing(_ textField: UIKit.UITextField)
  @_Concurrency.MainActor(unsafe) @objc final public func textFieldDidEndEditing(_ textField: UIKit.UITextField)
  @available(iOS 10.0, *)
  @_Concurrency.MainActor(unsafe) @objc final public func textFieldDidEndEditing(_ textField: UIKit.UITextField, reason: UIKit.UITextField.DidEndEditingReason)
  @_Concurrency.MainActor(unsafe) @objc final public func textField(_ textField: UIKit.UITextField, shouldChangeCharactersIn range: Foundation.NSRange, replacementString string: Swift.String) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc final public func textFieldShouldClear(_ textField: UIKit.UITextField) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc final public func textFieldShouldReturn(_ textField: UIKit.UITextField) -> Swift.Bool
}
@available(iOSApplicationExtension, unavailable)
extension MIBSFramework.IQKeyboardReturnKeyHandler : UIKit.UITextViewDelegate {
  @_Concurrency.MainActor(unsafe) @objc final public func textViewShouldBeginEditing(_ textView: UIKit.UITextView) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc final public func textViewShouldEndEditing(_ textView: UIKit.UITextView) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc final public func textViewDidBeginEditing(_ textView: UIKit.UITextView)
  @_Concurrency.MainActor(unsafe) @objc final public func textViewDidEndEditing(_ textView: UIKit.UITextView)
  @_Concurrency.MainActor(unsafe) @objc final public func textView(_ textView: UIKit.UITextView, shouldChangeTextIn range: Foundation.NSRange, replacementText text: Swift.String) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc final public func textViewDidChange(_ textView: UIKit.UITextView)
  @_Concurrency.MainActor(unsafe) @objc final public func textViewDidChangeSelection(_ textView: UIKit.UITextView)
  @available(iOS 10.0, *)
  @_Concurrency.MainActor(unsafe) @objc final public func textView(_ aTextView: UIKit.UITextView, shouldInteractWith URL: Foundation.URL, in characterRange: Foundation.NSRange, interaction: UIKit.UITextItemInteraction) -> Swift.Bool
  @available(iOS 10.0, *)
  @_Concurrency.MainActor(unsafe) @objc final public func textView(_ aTextView: UIKit.UITextView, shouldInteractWith textAttachment: UIKit.NSTextAttachment, in characterRange: Foundation.NSRange, interaction: UIKit.UITextItemInteraction) -> Swift.Bool
  @available(iOS, deprecated: 10.0)
  @_Concurrency.MainActor(unsafe) @objc final public func textView(_ aTextView: UIKit.UITextView, shouldInteractWith URL: Foundation.URL, in characterRange: Foundation.NSRange) -> Swift.Bool
  @available(iOS, deprecated: 10.0)
  @_Concurrency.MainActor(unsafe) @objc final public func textView(_ aTextView: UIKit.UITextView, shouldInteractWith textAttachment: UIKit.NSTextAttachment, in characterRange: Foundation.NSRange) -> Swift.Bool
}
@available(iOSApplicationExtension, unavailable)
extension MIBSFramework.IQKeyboardManager {
  @objc final public var enableDebugging: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
  @objc final public func registerAllNotifications()
  @objc final public func unregisterAllNotifications()
  public struct Static {
  }
}
extension MIBSFramework.Request {
  public static let didResumeNotification: Foundation.Notification.Name
  public static let didSuspendNotification: Foundation.Notification.Name
  public static let didCancelNotification: Foundation.Notification.Name
  public static let didFinishNotification: Foundation.Notification.Name
  public static let didResumeTaskNotification: Foundation.Notification.Name
  public static let didSuspendTaskNotification: Foundation.Notification.Name
  public static let didCancelTaskNotification: Foundation.Notification.Name
  public static let didCompleteTaskNotification: Foundation.Notification.Name
}
extension Foundation.Notification {
  public var request: MIBSFramework.Request? {
    get
  }
}
@_hasMissingDesignatedInitializers final public class AlamofireNotifications : MIBSFramework.EventMonitor {
  final public func requestDidResume(_ request: MIBSFramework.Request)
  final public func requestDidSuspend(_ request: MIBSFramework.Request)
  final public func requestDidCancel(_ request: MIBSFramework.Request)
  final public func requestDidFinish(_ request: MIBSFramework.Request)
  final public func request(_ request: MIBSFramework.Request, didResumeTask task: Foundation.URLSessionTask)
  final public func request(_ request: MIBSFramework.Request, didSuspendTask task: Foundation.URLSessionTask)
  final public func request(_ request: MIBSFramework.Request, didCancelTask task: Foundation.URLSessionTask)
  final public func request(_ request: MIBSFramework.Request, didCompleteTask task: Foundation.URLSessionTask, with error: MIBSFramework.AFError?)
  @objc deinit
}
extension MIBSFramework.Request {
  public typealias ValidationResult = Swift.Result<Swift.Void, Swift.Error>
}
extension MIBSFramework.DataRequest {
  public typealias Validation = (Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.Data?) -> MIBSFramework.DataRequest.ValidationResult
  @discardableResult
  public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  public func validate<S>(contentType acceptableContentTypes: @autoclosure @escaping () -> S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  public func validate() -> Self
}
extension MIBSFramework.DataStreamRequest {
  public typealias Validation = (_ request: Foundation.URLRequest?, _ response: Foundation.HTTPURLResponse) -> MIBSFramework.DataStreamRequest.ValidationResult
  @discardableResult
  final public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  final public func validate<S>(contentType acceptableContentTypes: @autoclosure @escaping () -> S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  final public func validate() -> Self
}
extension MIBSFramework.DownloadRequest {
  public typealias Validation = (_ request: Foundation.URLRequest?, _ response: Foundation.HTTPURLResponse, _ fileURL: Foundation.URL?) -> MIBSFramework.DownloadRequest.ValidationResult
  @discardableResult
  public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  public func validate<S>(contentType acceptableContentTypes: @autoclosure @escaping () -> S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  public func validate() -> Self
}
final public class LottieLogger {
  public init(assert: @escaping MIBSFramework.LottieLogger.Assert = { condition, message, file, line in
      // If we default to `Swift.assert` directly with `assert: Assert = Swift.assert`,
      // the call will unexpectedly not respect the -O flag and will crash in release
      // https://github.com/apple/swift/issues/60249
      Swift.assert(condition(), message(), file: file, line: line)
    }, assertionFailure: @escaping MIBSFramework.LottieLogger.AssertionFailure = { message, file, line in
      // If we default to `Swift.assertionFailure` directly with
      // `assertionFailure: AssertionFailure = Swift.assertionFailure`,
      // the call will unexpectedly not respect the -O flag and will crash in release
      // https://github.com/apple/swift/issues/60249
      Swift.assertionFailure(message(), file: file, line: line)
    }, warn: @escaping MIBSFramework.LottieLogger.Warn = { message, _, _ in
    }, info: @escaping MIBSFramework.LottieLogger.Info = { message in
    })
  public typealias Assert = (_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> Swift.String, _ fileID: Swift.StaticString, _ line: Swift.UInt) -> Swift.Void
  public typealias AssertionFailure = (_ message: @autoclosure () -> Swift.String, _ fileID: Swift.StaticString, _ line: Swift.UInt) -> Swift.Void
  public typealias Warn = (_ message: @autoclosure () -> Swift.String, _ fileID: Swift.StaticString, _ line: Swift.UInt) -> Swift.Void
  public typealias Info = (_ message: @autoclosure () -> Swift.String) -> Swift.Void
  public static var shared: MIBSFramework.LottieLogger
  final public func assert(_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> Swift.String = String(), fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  final public func assertionFailure(_ message: @autoclosure () -> Swift.String = String(), fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  final public func warn(_ message: @autoclosure () -> Swift.String = String(), fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  final public func info(_ message: @autoclosure () -> Swift.String = String())
  @objc deinit
}
extension MIBSFramework.LottieLogger {
  public static var printToConsole: MIBSFramework.LottieLogger {
    get
  }
}
final public class URLEncodedFormEncoder {
  public enum ArrayEncoding {
    case brackets
    case noBrackets
    case indexInBrackets
    public static func == (a: MIBSFramework.URLEncodedFormEncoder.ArrayEncoding, b: MIBSFramework.URLEncodedFormEncoder.ArrayEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum BoolEncoding {
    case numeric
    case literal
    public static func == (a: MIBSFramework.URLEncodedFormEncoder.BoolEncoding, b: MIBSFramework.URLEncodedFormEncoder.BoolEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum DataEncoding {
    case deferredToData
    case base64
    case custom((Foundation.Data) throws -> Swift.String)
  }
  public enum DateEncoding {
    case deferredToDate
    case secondsSince1970
    case millisecondsSince1970
    case iso8601
    case formatted(Foundation.DateFormatter)
    case custom((Foundation.Date) throws -> Swift.String)
  }
  public enum KeyEncoding {
    case useDefaultKeys
    case convertToSnakeCase
    case convertToKebabCase
    case capitalized
    case uppercased
    case lowercased
    case custom((Swift.String) -> Swift.String)
  }
  public enum SpaceEncoding {
    case percentEscaped
    case plusReplaced
    public static func == (a: MIBSFramework.URLEncodedFormEncoder.SpaceEncoding, b: MIBSFramework.URLEncodedFormEncoder.SpaceEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Error : Swift.Error {
    case invalidRootObject(Swift.String)
  }
  final public let alphabetizeKeyValuePairs: Swift.Bool
  final public let arrayEncoding: MIBSFramework.URLEncodedFormEncoder.ArrayEncoding
  final public let boolEncoding: MIBSFramework.URLEncodedFormEncoder.BoolEncoding
  final public let dataEncoding: MIBSFramework.URLEncodedFormEncoder.DataEncoding
  final public let dateEncoding: MIBSFramework.URLEncodedFormEncoder.DateEncoding
  final public let keyEncoding: MIBSFramework.URLEncodedFormEncoder.KeyEncoding
  final public let spaceEncoding: MIBSFramework.URLEncodedFormEncoder.SpaceEncoding
  final public var allowedCharacters: Foundation.CharacterSet
  public init(alphabetizeKeyValuePairs: Swift.Bool = true, arrayEncoding: MIBSFramework.URLEncodedFormEncoder.ArrayEncoding = .brackets, boolEncoding: MIBSFramework.URLEncodedFormEncoder.BoolEncoding = .numeric, dataEncoding: MIBSFramework.URLEncodedFormEncoder.DataEncoding = .base64, dateEncoding: MIBSFramework.URLEncodedFormEncoder.DateEncoding = .deferredToDate, keyEncoding: MIBSFramework.URLEncodedFormEncoder.KeyEncoding = .useDefaultKeys, spaceEncoding: MIBSFramework.URLEncodedFormEncoder.SpaceEncoding = .percentEscaped, allowedCharacters: Foundation.CharacterSet = .afURLQueryAllowed)
  final public func encode(_ value: Swift.Encodable) throws -> Swift.String
  final public func encode(_ value: Swift.Encodable) throws -> Foundation.Data
  @objc deinit
}
extension Foundation.CharacterSet {
  public static let afURLQueryAllowed: Foundation.CharacterSet
}
public struct Vector1D : Swift.Hashable {
  public init(_ value: Swift.Double)
  public let value: Swift.Double
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: MIBSFramework.Vector1D, b: MIBSFramework.Vector1D) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct Vector3D : Swift.Hashable {
  public let x: Swift.Double
  public let y: Swift.Double
  public let z: Swift.Double
  public init(x: Swift.Double, y: Swift.Double, z: Swift.Double)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: MIBSFramework.Vector3D, b: MIBSFramework.Vector3D) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers @objc @_Concurrency.MainActor(unsafe) public class CardAndBarcodeDetectionViewController : MIBSFramework.BaseCardDetectionViewController {
  @objc @_Concurrency.MainActor(unsafe) weak public var delegate: MIBSFramework.CardAndBarcodeDetectionViewControllerDelegate?
  @objc @_Concurrency.MainActor(unsafe) final public let settings: MIBSFramework.CardAndBarcodeDetectionSettings
  @objc @_Concurrency.MainActor(unsafe) public init(settings: MIBSFramework.CardAndBarcodeDetectionSettings)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLoad()
  @objc deinit
}
@objc public class MIBSInit : ObjectiveC.NSObject {
  @objc public var uv: UIKit.UIViewController!
  @objc public init(uv: UIKit.UIViewController)
  @objc public func hello(to whom: Swift.String) -> Swift.String
  @objc public func loadData()
  @objc deinit
}
extension UIKit.UIFont {
  public static func jbs_registerFont(withFilenameString filenameString: Swift.String, bundle: Foundation.Bundle)
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOSApplicationExtension, unavailable)
@objc final public class IQKeyboardManager : ObjectiveC.NSObject {
  @objc public static let shared: MIBSFramework.IQKeyboardManager
  @objc final public var enable: Swift.Bool {
    @objc get
    @objc set
  }
  @objc final public var keyboardDistanceFromTextField: CoreFoundation.CGFloat
  @objc final public var enableAutoToolbar: Swift.Bool {
    @objc get
    @objc set
  }
  @objc final public var toolbarManageBehaviour: MIBSFramework.IQAutoToolbarManageBehaviour
  @objc final public var shouldToolbarUsesTextFieldTintColor: Swift.Bool
  @objc final public var toolbarTintColor: UIKit.UIColor?
  @objc final public var toolbarBarTintColor: UIKit.UIColor?
  @objc final public var previousNextDisplayMode: MIBSFramework.IQPreviousNextDisplayMode
  @objc final public var toolbarPreviousBarButtonItemImage: UIKit.UIImage?
  @objc final public var toolbarNextBarButtonItemImage: UIKit.UIImage?
  @objc final public var toolbarDoneBarButtonItemImage: UIKit.UIImage?
  @objc final public var toolbarPreviousBarButtonItemText: Swift.String?
  @objc final public var toolbarPreviousBarButtonItemAccessibilityLabel: Swift.String?
  @objc final public var toolbarNextBarButtonItemText: Swift.String?
  @objc final public var toolbarNextBarButtonItemAccessibilityLabel: Swift.String?
  @objc final public var toolbarDoneBarButtonItemText: Swift.String?
  @objc final public var toolbarDoneBarButtonItemAccessibilityLabel: Swift.String?
  @objc final public var shouldShowToolbarPlaceholder: Swift.Bool
  @objc final public var placeholderFont: UIKit.UIFont?
  @objc final public var placeholderColor: UIKit.UIColor?
  @objc final public var placeholderButtonColor: UIKit.UIColor?
  @objc final public var overrideKeyboardAppearance: Swift.Bool
  @objc final public var keyboardAppearance: UIKit.UIKeyboardAppearance
  @objc final public var shouldResignOnTouchOutside: Swift.Bool {
    @objc get
    @objc set
  }
  @objc final public var resignFirstResponderGesture: UIKit.UITapGestureRecognizer {
    @objc get
    @objc set
  }
  @discardableResult
  @objc final public func resignFirstResponder() -> Swift.Bool
  @objc final public var shouldPlayInputClicks: Swift.Bool
  @objc final public var layoutIfNeededOnUpdate: Swift.Bool
  @objc final public var disabledDistanceHandlingClasses: [UIKit.UIViewController.Type]
  @objc final public var enabledDistanceHandlingClasses: [UIKit.UIViewController.Type]
  @objc final public var disabledToolbarClasses: [UIKit.UIViewController.Type]
  @objc final public var enabledToolbarClasses: [UIKit.UIViewController.Type]
  @objc final public var toolbarPreviousNextAllowedClasses: [UIKit.UIView.Type]
  @objc final public var disabledTouchResignedClasses: [UIKit.UIViewController.Type]
  @objc final public var enabledTouchResignedClasses: [UIKit.UIViewController.Type]
  @objc final public var touchResignedGestureIgnoreClasses: [UIKit.UIView.Type]
  @objc final public func registerTextFieldViewClass(_ aClass: UIKit.UIView.Type, didBeginEditingNotificationName: Swift.String, didEndEditingNotificationName: Swift.String)
  @objc final public func unregisterTextFieldViewClass(_ aClass: UIKit.UIView.Type, didBeginEditingNotificationName: Swift.String, didEndEditingNotificationName: Swift.String)
  @objc deinit
  @objc final public func reloadLayoutIfNeeded()
}
@available(iOSApplicationExtension, unavailable)
extension MIBSFramework.IQKeyboardManager : UIKit.UIGestureRecognizerDelegate {
  @_Concurrency.MainActor(unsafe) @objc final public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc final public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldReceive touch: UIKit.UITouch) -> Swift.Bool
}
public struct MapError : Swift.Error {
  public var key: Swift.String?
  public var currentValue: Any?
  public var reason: Swift.String?
  public var file: Swift.StaticString?
  public var function: Swift.StaticString?
  public var line: Swift.UInt?
  public init(key: Swift.String?, currentValue: Any?, reason: Swift.String?, file: Swift.StaticString? = nil, function: Swift.StaticString? = nil, line: Swift.UInt? = nil)
}
extension MIBSFramework.MapError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct AlamofireExtension<ExtendedType> {
  public var type: ExtendedType {
    get
  }
  public init(_ type: ExtendedType)
}
public protocol AlamofireExtended {
  associatedtype ExtendedType
  static var af: MIBSFramework.AlamofireExtension<Self.ExtendedType>.Type { get set }
  var af: MIBSFramework.AlamofireExtension<Self.ExtendedType> { get set }
}
extension MIBSFramework.AlamofireExtended {
  public static var af: MIBSFramework.AlamofireExtension<Self>.Type {
    get
    set
  }
  public var af: MIBSFramework.AlamofireExtension<Self> {
    get
    set
  }
}
open class DateTransform : MIBSFramework.TransformType {
  public typealias Object = Foundation.Date
  public typealias JSON = Swift.Double
  public enum Unit : Foundation.TimeInterval {
    case seconds
    case milliseconds
    public init?(rawValue: Foundation.TimeInterval)
    public typealias RawValue = Foundation.TimeInterval
    public var rawValue: Foundation.TimeInterval {
      get
    }
  }
  public init(unit: MIBSFramework.DateTransform.Unit = .seconds)
  open func transformFromJSON(_ value: Any?) -> Foundation.Date?
  open func transformToJSON(_ value: Foundation.Date?) -> Swift.Double?
  @objc deinit
}
@available(iOSApplicationExtension, unavailable)
@objc public enum IQAutoToolbarManageBehaviour : Swift.Int {
  case bySubviews
  case byTag
  case byPosition
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@available(iOSApplicationExtension, unavailable)
@objc public enum IQPreviousNextDisplayMode : Swift.Int {
  case `default`
  case alwaysHide
  case alwaysShow
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@available(iOSApplicationExtension, unavailable)
@objc public enum IQEnableMode : Swift.Int {
  case `default`
  case enabled
  case disabled
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public protocol EventMonitor {
  var queue: Dispatch.DispatchQueue { get }
  func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  func request(_ request: MIBSFramework.Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  func request(_ request: MIBSFramework.Request, didFailToCreateURLRequestWithError error: MIBSFramework.AFError)
  func request(_ request: MIBSFramework.Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  func request(_ request: MIBSFramework.Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: MIBSFramework.AFError)
  func request(_ request: MIBSFramework.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  func request(_ request: MIBSFramework.Request, didCreateTask task: Foundation.URLSessionTask)
  func request(_ request: MIBSFramework.Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  func request(_ request: MIBSFramework.Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: MIBSFramework.AFError)
  func request(_ request: MIBSFramework.Request, didCompleteTask task: Foundation.URLSessionTask, with error: MIBSFramework.AFError?)
  func requestIsRetrying(_ request: MIBSFramework.Request)
  func requestDidFinish(_ request: MIBSFramework.Request)
  func requestDidResume(_ request: MIBSFramework.Request)
  func request(_ request: MIBSFramework.Request, didResumeTask task: Foundation.URLSessionTask)
  func requestDidSuspend(_ request: MIBSFramework.Request)
  func request(_ request: MIBSFramework.Request, didSuspendTask task: Foundation.URLSessionTask)
  func requestDidCancel(_ request: MIBSFramework.Request)
  func request(_ request: MIBSFramework.Request, didCancelTask task: Foundation.URLSessionTask)
  func request(_ request: MIBSFramework.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: MIBSFramework.Request.ValidationResult)
  func request(_ request: MIBSFramework.DataRequest, didParseResponse response: MIBSFramework.DataResponse<Foundation.Data?, MIBSFramework.AFError>)
  func request<Value>(_ request: MIBSFramework.DataRequest, didParseResponse response: MIBSFramework.DataResponse<Value, MIBSFramework.AFError>)
  func request(_ request: MIBSFramework.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: MIBSFramework.Request.ValidationResult)
  func request<Value>(_ request: MIBSFramework.DataStreamRequest, didParseStream result: Swift.Result<Value, MIBSFramework.AFError>)
  func request(_ request: MIBSFramework.UploadRequest, didCreateUploadable uploadable: MIBSFramework.UploadRequest.Uploadable)
  func request(_ request: MIBSFramework.UploadRequest, didFailToCreateUploadableWithError error: MIBSFramework.AFError)
  func request(_ request: MIBSFramework.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  func request(_ request: MIBSFramework.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, MIBSFramework.AFError>)
  func request(_ request: MIBSFramework.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  func request(_ request: MIBSFramework.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: MIBSFramework.Request.ValidationResult)
  func request(_ request: MIBSFramework.DownloadRequest, didParseResponse response: MIBSFramework.DownloadResponse<Foundation.URL?, MIBSFramework.AFError>)
  func request<Value>(_ request: MIBSFramework.DownloadRequest, didParseResponse response: MIBSFramework.DownloadResponse<Value, MIBSFramework.AFError>)
}
extension MIBSFramework.EventMonitor {
  public var queue: Dispatch.DispatchQueue {
    get
  }
  public func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  public func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  public func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  public func request(_ request: MIBSFramework.Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  public func request(_ request: MIBSFramework.Request, didFailToCreateURLRequestWithError error: MIBSFramework.AFError)
  public func request(_ request: MIBSFramework.Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  public func request(_ request: MIBSFramework.Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: MIBSFramework.AFError)
  public func request(_ request: MIBSFramework.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  public func request(_ request: MIBSFramework.Request, didCreateTask task: Foundation.URLSessionTask)
  public func request(_ request: MIBSFramework.Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  public func request(_ request: MIBSFramework.Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: MIBSFramework.AFError)
  public func request(_ request: MIBSFramework.Request, didCompleteTask task: Foundation.URLSessionTask, with error: MIBSFramework.AFError?)
  public func requestIsRetrying(_ request: MIBSFramework.Request)
  public func requestDidFinish(_ request: MIBSFramework.Request)
  public func requestDidResume(_ request: MIBSFramework.Request)
  public func request(_ request: MIBSFramework.Request, didResumeTask task: Foundation.URLSessionTask)
  public func requestDidSuspend(_ request: MIBSFramework.Request)
  public func request(_ request: MIBSFramework.Request, didSuspendTask task: Foundation.URLSessionTask)
  public func requestDidCancel(_ request: MIBSFramework.Request)
  public func request(_ request: MIBSFramework.Request, didCancelTask task: Foundation.URLSessionTask)
  public func request(_ request: MIBSFramework.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: MIBSFramework.Request.ValidationResult)
  public func request(_ request: MIBSFramework.DataRequest, didParseResponse response: MIBSFramework.DataResponse<Foundation.Data?, MIBSFramework.AFError>)
  public func request<Value>(_ request: MIBSFramework.DataRequest, didParseResponse response: MIBSFramework.DataResponse<Value, MIBSFramework.AFError>)
  public func request(_ request: MIBSFramework.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: MIBSFramework.Request.ValidationResult)
  public func request<Value>(_ request: MIBSFramework.DataStreamRequest, didParseStream result: Swift.Result<Value, MIBSFramework.AFError>)
  public func request(_ request: MIBSFramework.UploadRequest, didCreateUploadable uploadable: MIBSFramework.UploadRequest.Uploadable)
  public func request(_ request: MIBSFramework.UploadRequest, didFailToCreateUploadableWithError error: MIBSFramework.AFError)
  public func request(_ request: MIBSFramework.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  public func request(_ request: MIBSFramework.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, MIBSFramework.AFError>)
  public func request(_ request: MIBSFramework.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  public func request(_ request: MIBSFramework.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: MIBSFramework.Request.ValidationResult)
  public func request(_ request: MIBSFramework.DownloadRequest, didParseResponse response: MIBSFramework.DownloadResponse<Foundation.URL?, MIBSFramework.AFError>)
  public func request<Value>(_ request: MIBSFramework.DownloadRequest, didParseResponse response: MIBSFramework.DownloadResponse<Value, MIBSFramework.AFError>)
}
@_hasMissingDesignatedInitializers final public class CompositeEventMonitor : MIBSFramework.EventMonitor {
  final public let queue: Dispatch.DispatchQueue
  final public func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  final public func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  final public func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  final public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  final public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  final public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  final public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  final public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  final public func request(_ request: MIBSFramework.Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  final public func request(_ request: MIBSFramework.Request, didFailToCreateURLRequestWithError error: MIBSFramework.AFError)
  final public func request(_ request: MIBSFramework.Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  final public func request(_ request: MIBSFramework.Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: MIBSFramework.AFError)
  final public func request(_ request: MIBSFramework.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  final public func request(_ request: MIBSFramework.Request, didCreateTask task: Foundation.URLSessionTask)
  final public func request(_ request: MIBSFramework.Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  final public func request(_ request: MIBSFramework.Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: MIBSFramework.AFError)
  final public func request(_ request: MIBSFramework.Request, didCompleteTask task: Foundation.URLSessionTask, with error: MIBSFramework.AFError?)
  final public func requestIsRetrying(_ request: MIBSFramework.Request)
  final public func requestDidFinish(_ request: MIBSFramework.Request)
  final public func requestDidResume(_ request: MIBSFramework.Request)
  final public func request(_ request: MIBSFramework.Request, didResumeTask task: Foundation.URLSessionTask)
  final public func requestDidSuspend(_ request: MIBSFramework.Request)
  final public func request(_ request: MIBSFramework.Request, didSuspendTask task: Foundation.URLSessionTask)
  final public func requestDidCancel(_ request: MIBSFramework.Request)
  final public func request(_ request: MIBSFramework.Request, didCancelTask task: Foundation.URLSessionTask)
  final public func request(_ request: MIBSFramework.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: MIBSFramework.Request.ValidationResult)
  final public func request(_ request: MIBSFramework.DataRequest, didParseResponse response: MIBSFramework.DataResponse<Foundation.Data?, MIBSFramework.AFError>)
  final public func request<Value>(_ request: MIBSFramework.DataRequest, didParseResponse response: MIBSFramework.DataResponse<Value, MIBSFramework.AFError>)
  final public func request(_ request: MIBSFramework.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: MIBSFramework.Request.ValidationResult)
  final public func request<Value>(_ request: MIBSFramework.DataStreamRequest, didParseStream result: Swift.Result<Value, MIBSFramework.AFError>)
  final public func request(_ request: MIBSFramework.UploadRequest, didCreateUploadable uploadable: MIBSFramework.UploadRequest.Uploadable)
  final public func request(_ request: MIBSFramework.UploadRequest, didFailToCreateUploadableWithError error: MIBSFramework.AFError)
  final public func request(_ request: MIBSFramework.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  final public func request(_ request: MIBSFramework.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, MIBSFramework.AFError>)
  final public func request(_ request: MIBSFramework.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  final public func request(_ request: MIBSFramework.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: MIBSFramework.Request.ValidationResult)
  final public func request(_ request: MIBSFramework.DownloadRequest, didParseResponse response: MIBSFramework.DownloadResponse<Foundation.URL?, MIBSFramework.AFError>)
  final public func request<Value>(_ request: MIBSFramework.DownloadRequest, didParseResponse response: MIBSFramework.DownloadResponse<Value, MIBSFramework.AFError>)
  @objc deinit
}
open class ClosureEventMonitor : MIBSFramework.EventMonitor {
  open var sessionDidBecomeInvalidWithError: ((Foundation.URLSession, Swift.Error?) -> Swift.Void)?
  open var taskDidReceiveChallenge: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.URLAuthenticationChallenge) -> Swift.Void)?
  open var taskDidSendBodyData: ((Foundation.URLSession, Foundation.URLSessionTask, Swift.Int64, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var taskNeedNewBodyStream: ((Foundation.URLSession, Foundation.URLSessionTask) -> Swift.Void)?
  open var taskWillPerformHTTPRedirection: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.HTTPURLResponse, Foundation.URLRequest) -> Swift.Void)?
  open var taskDidFinishCollectingMetrics: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.URLSessionTaskMetrics) -> Swift.Void)?
  open var taskDidComplete: ((Foundation.URLSession, Foundation.URLSessionTask, Swift.Error?) -> Swift.Void)?
  open var taskIsWaitingForConnectivity: ((Foundation.URLSession, Foundation.URLSessionTask) -> Swift.Void)?
  open var dataTaskDidReceiveData: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.Data) -> Swift.Void)?
  open var dataTaskWillCacheResponse: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Swift.Void)?
  open var downloadTaskDidFinishDownloadingToURL: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Foundation.URL) -> Swift.Void)?
  open var downloadTaskDidWriteData: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Swift.Int64, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var downloadTaskDidResumeAtOffset: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var requestDidCreateInitialURLRequest: ((MIBSFramework.Request, Foundation.URLRequest) -> Swift.Void)?
  open var requestDidFailToCreateURLRequestWithError: ((MIBSFramework.Request, MIBSFramework.AFError) -> Swift.Void)?
  open var requestDidAdaptInitialRequestToAdaptedRequest: ((MIBSFramework.Request, Foundation.URLRequest, Foundation.URLRequest) -> Swift.Void)?
  open var requestDidFailToAdaptURLRequestWithError: ((MIBSFramework.Request, Foundation.URLRequest, MIBSFramework.AFError) -> Swift.Void)?
  open var requestDidCreateURLRequest: ((MIBSFramework.Request, Foundation.URLRequest) -> Swift.Void)?
  open var requestDidCreateTask: ((MIBSFramework.Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidGatherMetrics: ((MIBSFramework.Request, Foundation.URLSessionTaskMetrics) -> Swift.Void)?
  open var requestDidFailTaskEarlyWithError: ((MIBSFramework.Request, Foundation.URLSessionTask, MIBSFramework.AFError) -> Swift.Void)?
  open var requestDidCompleteTaskWithError: ((MIBSFramework.Request, Foundation.URLSessionTask, MIBSFramework.AFError?) -> Swift.Void)?
  open var requestIsRetrying: ((MIBSFramework.Request) -> Swift.Void)?
  open var requestDidFinish: ((MIBSFramework.Request) -> Swift.Void)?
  open var requestDidResume: ((MIBSFramework.Request) -> Swift.Void)?
  open var requestDidResumeTask: ((MIBSFramework.Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidSuspend: ((MIBSFramework.Request) -> Swift.Void)?
  open var requestDidSuspendTask: ((MIBSFramework.Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidCancel: ((MIBSFramework.Request) -> Swift.Void)?
  open var requestDidCancelTask: ((MIBSFramework.Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidValidateRequestResponseDataWithResult: ((MIBSFramework.DataRequest, Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.Data?, MIBSFramework.Request.ValidationResult) -> Swift.Void)?
  open var requestDidParseResponse: ((MIBSFramework.DataRequest, MIBSFramework.DataResponse<Foundation.Data?, MIBSFramework.AFError>) -> Swift.Void)?
  open var requestDidValidateRequestResponseWithResult: ((MIBSFramework.DataStreamRequest, Foundation.URLRequest?, Foundation.HTTPURLResponse, MIBSFramework.Request.ValidationResult) -> Swift.Void)?
  open var requestDidCreateUploadable: ((MIBSFramework.UploadRequest, MIBSFramework.UploadRequest.Uploadable) -> Swift.Void)?
  open var requestDidFailToCreateUploadableWithError: ((MIBSFramework.UploadRequest, MIBSFramework.AFError) -> Swift.Void)?
  open var requestDidProvideInputStream: ((MIBSFramework.UploadRequest, Foundation.InputStream) -> Swift.Void)?
  open var requestDidFinishDownloadingUsingTaskWithResult: ((MIBSFramework.DownloadRequest, Foundation.URLSessionTask, Swift.Result<Foundation.URL, MIBSFramework.AFError>) -> Swift.Void)?
  open var requestDidCreateDestinationURL: ((MIBSFramework.DownloadRequest, Foundation.URL) -> Swift.Void)?
  open var requestDidValidateRequestResponseFileURLWithResult: ((MIBSFramework.DownloadRequest, Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.URL?, MIBSFramework.Request.ValidationResult) -> Swift.Void)?
  open var requestDidParseDownloadResponse: ((MIBSFramework.DownloadRequest, MIBSFramework.DownloadResponse<Foundation.URL?, MIBSFramework.AFError>) -> Swift.Void)?
  final public let queue: Dispatch.DispatchQueue
  public init(queue: Dispatch.DispatchQueue = .main)
  open func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  open func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  open func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  open func request(_ request: MIBSFramework.Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  open func request(_ request: MIBSFramework.Request, didFailToCreateURLRequestWithError error: MIBSFramework.AFError)
  open func request(_ request: MIBSFramework.Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  open func request(_ request: MIBSFramework.Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: MIBSFramework.AFError)
  open func request(_ request: MIBSFramework.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  open func request(_ request: MIBSFramework.Request, didCreateTask task: Foundation.URLSessionTask)
  open func request(_ request: MIBSFramework.Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  open func request(_ request: MIBSFramework.Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: MIBSFramework.AFError)
  open func request(_ request: MIBSFramework.Request, didCompleteTask task: Foundation.URLSessionTask, with error: MIBSFramework.AFError?)
  open func requestIsRetrying(_ request: MIBSFramework.Request)
  open func requestDidFinish(_ request: MIBSFramework.Request)
  open func requestDidResume(_ request: MIBSFramework.Request)
  public func request(_ request: MIBSFramework.Request, didResumeTask task: Foundation.URLSessionTask)
  open func requestDidSuspend(_ request: MIBSFramework.Request)
  public func request(_ request: MIBSFramework.Request, didSuspendTask task: Foundation.URLSessionTask)
  open func requestDidCancel(_ request: MIBSFramework.Request)
  public func request(_ request: MIBSFramework.Request, didCancelTask task: Foundation.URLSessionTask)
  open func request(_ request: MIBSFramework.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: MIBSFramework.Request.ValidationResult)
  open func request(_ request: MIBSFramework.DataRequest, didParseResponse response: MIBSFramework.DataResponse<Foundation.Data?, MIBSFramework.AFError>)
  public func request(_ request: MIBSFramework.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: MIBSFramework.Request.ValidationResult)
  open func request(_ request: MIBSFramework.UploadRequest, didCreateUploadable uploadable: MIBSFramework.UploadRequest.Uploadable)
  open func request(_ request: MIBSFramework.UploadRequest, didFailToCreateUploadableWithError error: MIBSFramework.AFError)
  open func request(_ request: MIBSFramework.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  open func request(_ request: MIBSFramework.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, MIBSFramework.AFError>)
  open func request(_ request: MIBSFramework.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  open func request(_ request: MIBSFramework.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: MIBSFramework.Request.ValidationResult)
  open func request(_ request: MIBSFramework.DownloadRequest, didParseResponse response: MIBSFramework.DownloadResponse<Foundation.URL?, MIBSFramework.AFError>)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Asset : Swift.Codable {
  required public init(from decoder: Swift.Decoder) throws
  final public let id: Swift.String
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
}
public struct HTTPMethod : Swift.RawRepresentable, Swift.Equatable, Swift.Hashable {
  public static let connect: MIBSFramework.HTTPMethod
  public static let delete: MIBSFramework.HTTPMethod
  public static let get: MIBSFramework.HTTPMethod
  public static let head: MIBSFramework.HTTPMethod
  public static let options: MIBSFramework.HTTPMethod
  public static let patch: MIBSFramework.HTTPMethod
  public static let post: MIBSFramework.HTTPMethod
  public static let put: MIBSFramework.HTTPMethod
  public static let query: MIBSFramework.HTTPMethod
  public static let trace: MIBSFramework.HTTPMethod
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public typealias RawValue = Swift.String
}
public protocol AnimationCacheProvider {
  func animation(forKey: Swift.String) -> MIBSFramework.Animation?
  func setAnimation(_ animation: MIBSFramework.Animation, forKey: Swift.String)
  func clearCache()
}
@_hasMissingDesignatedInitializers open class NetworkReachabilityManager {
  public enum NetworkReachabilityStatus {
    case unknown
    case notReachable
    case reachable(MIBSFramework.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType)
    public enum ConnectionType {
      case ethernetOrWiFi
      case cellular
      public static func == (a: MIBSFramework.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType, b: MIBSFramework.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
  }
  public typealias Listener = (MIBSFramework.NetworkReachabilityManager.NetworkReachabilityStatus) -> Swift.Void
  public static let `default`: MIBSFramework.NetworkReachabilityManager?
  open var isReachable: Swift.Bool {
    get
  }
  open var isReachableOnCellular: Swift.Bool {
    get
  }
  open var isReachableOnEthernetOrWiFi: Swift.Bool {
    get
  }
  final public let reachabilityQueue: Dispatch.DispatchQueue
  open var flags: SystemConfiguration.SCNetworkReachabilityFlags? {
    get
  }
  open var status: MIBSFramework.NetworkReachabilityManager.NetworkReachabilityStatus {
    get
  }
  convenience public init?(host: Swift.String)
  convenience public init?()
  @objc deinit
  @discardableResult
  open func startListening(onQueue queue: Dispatch.DispatchQueue = .main, onUpdatePerforming listener: @escaping MIBSFramework.NetworkReachabilityManager.Listener) -> Swift.Bool
  open func stopListening()
}
extension MIBSFramework.NetworkReachabilityManager.NetworkReachabilityStatus : Swift.Equatable {
  public static func == (a: MIBSFramework.NetworkReachabilityManager.NetworkReachabilityStatus, b: MIBSFramework.NetworkReachabilityManager.NetworkReachabilityStatus) -> Swift.Bool
}
public class FilepathImageProvider : MIBSFramework.AnimationImageProvider {
  public init(filepath: Swift.String)
  public init(filepath: Foundation.URL)
  public func imageForAsset(asset: MIBSFramework.ImageAsset) -> CoreGraphics.CGImage?
  @objc deinit
}
open class EnumTransform<T> : MIBSFramework.TransformType where T : Swift.RawRepresentable {
  public typealias Object = T
  public typealias JSON = T.RawValue
  public init()
  open func transformFromJSON(_ value: Any?) -> T?
  open func transformToJSON(_ value: T?) -> T.RawValue?
  @objc deinit
}
public protocol DataResponseSerializerProtocol {
  associatedtype SerializedObject
  func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> Self.SerializedObject
}
public protocol DownloadResponseSerializerProtocol {
  associatedtype SerializedObject
  func serializeDownload(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, error: Swift.Error?) throws -> Self.SerializedObject
}
public protocol ResponseSerializer : MIBSFramework.DataResponseSerializerProtocol, MIBSFramework.DownloadResponseSerializerProtocol {
  var dataPreprocessor: MIBSFramework.DataPreprocessor { get }
  var emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod> { get }
  var emptyResponseCodes: Swift.Set<Swift.Int> { get }
}
public protocol DataPreprocessor {
  func preprocess(_ data: Foundation.Data) throws -> Foundation.Data
}
public struct PassthroughPreprocessor : MIBSFramework.DataPreprocessor {
  public init()
  public func preprocess(_ data: Foundation.Data) throws -> Foundation.Data
}
public struct GoogleXSSIPreprocessor : MIBSFramework.DataPreprocessor {
  public init()
  public func preprocess(_ data: Foundation.Data) throws -> Foundation.Data
}
extension MIBSFramework.DataPreprocessor where Self == MIBSFramework.PassthroughPreprocessor {
  public static var passthrough: MIBSFramework.PassthroughPreprocessor {
    get
  }
}
extension MIBSFramework.DataPreprocessor where Self == MIBSFramework.GoogleXSSIPreprocessor {
  public static var googleXSSI: MIBSFramework.GoogleXSSIPreprocessor {
    get
  }
}
extension MIBSFramework.ResponseSerializer {
  public static var defaultDataPreprocessor: MIBSFramework.DataPreprocessor {
    get
  }
  public static var defaultEmptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod> {
    get
  }
  public static var defaultEmptyResponseCodes: Swift.Set<Swift.Int> {
    get
  }
  public var dataPreprocessor: MIBSFramework.DataPreprocessor {
    get
  }
  public var emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod> {
    get
  }
  public var emptyResponseCodes: Swift.Set<Swift.Int> {
    get
  }
  public func requestAllowsEmptyResponseData(_ request: Foundation.URLRequest?) -> Swift.Bool?
  public func responseAllowsEmptyResponseData(_ response: Foundation.HTTPURLResponse?) -> Swift.Bool?
  public func emptyResponseAllowed(forRequest request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?) -> Swift.Bool
}
extension MIBSFramework.DownloadResponseSerializerProtocol where Self : MIBSFramework.DataResponseSerializerProtocol {
  public func serializeDownload(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, error: Swift.Error?) throws -> Self.SerializedObject
}
extension MIBSFramework.DataRequest {
  @discardableResult
  public func response(queue: Dispatch.DispatchQueue = .main, completionHandler: @escaping (MIBSFramework.AFDataResponse<Foundation.Data?>) -> Swift.Void) -> Self
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (MIBSFramework.AFDataResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : MIBSFramework.DataResponseSerializerProtocol
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (MIBSFramework.AFDataResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : MIBSFramework.ResponseSerializer
}
extension MIBSFramework.DownloadRequest {
  @discardableResult
  public func response(queue: Dispatch.DispatchQueue = .main, completionHandler: @escaping (MIBSFramework.AFDownloadResponse<Foundation.URL?>) -> Swift.Void) -> Self
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (MIBSFramework.AFDownloadResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : MIBSFramework.DownloadResponseSerializerProtocol
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (MIBSFramework.AFDownloadResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : MIBSFramework.ResponseSerializer
}
public struct URLResponseSerializer : MIBSFramework.DownloadResponseSerializerProtocol {
  public init()
  public func serializeDownload(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, error: Swift.Error?) throws -> Foundation.URL
  public typealias SerializedObject = Foundation.URL
}
extension MIBSFramework.DownloadResponseSerializerProtocol where Self == MIBSFramework.URLResponseSerializer {
  public static var url: MIBSFramework.URLResponseSerializer {
    get
  }
}
extension MIBSFramework.DownloadRequest {
  @discardableResult
  public func responseURL(queue: Dispatch.DispatchQueue = .main, completionHandler: @escaping (MIBSFramework.AFDownloadResponse<Foundation.URL>) -> Swift.Void) -> Self
}
final public class DataResponseSerializer : MIBSFramework.ResponseSerializer {
  final public let dataPreprocessor: MIBSFramework.DataPreprocessor
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod>
  public init(dataPreprocessor: MIBSFramework.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> Foundation.Data
  public typealias SerializedObject = Foundation.Data
  @objc deinit
}
extension MIBSFramework.ResponseSerializer where Self == MIBSFramework.DataResponseSerializer {
  public static var data: MIBSFramework.DataResponseSerializer {
    get
  }
  public static func data(dataPreprocessor: MIBSFramework.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> MIBSFramework.DataResponseSerializer
}
extension MIBSFramework.DataRequest {
  @discardableResult
  public func responseData(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: MIBSFramework.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (MIBSFramework.AFDataResponse<Foundation.Data>) -> Swift.Void) -> Self
}
extension MIBSFramework.DownloadRequest {
  @discardableResult
  public func responseData(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: MIBSFramework.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (MIBSFramework.AFDownloadResponse<Foundation.Data>) -> Swift.Void) -> Self
}
final public class StringResponseSerializer : MIBSFramework.ResponseSerializer {
  final public let dataPreprocessor: MIBSFramework.DataPreprocessor
  final public let encoding: Swift.String.Encoding?
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod>
  public init(dataPreprocessor: MIBSFramework.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> Swift.String
  public typealias SerializedObject = Swift.String
  @objc deinit
}
extension MIBSFramework.ResponseSerializer where Self == MIBSFramework.StringResponseSerializer {
  public static var string: MIBSFramework.StringResponseSerializer {
    get
  }
  public static func string(dataPreprocessor: MIBSFramework.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> MIBSFramework.StringResponseSerializer
}
extension MIBSFramework.DataRequest {
  @discardableResult
  public func responseString(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: MIBSFramework.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (MIBSFramework.AFDataResponse<Swift.String>) -> Swift.Void) -> Self
}
extension MIBSFramework.DownloadRequest {
  @discardableResult
  public func responseString(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: MIBSFramework.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (MIBSFramework.AFDownloadResponse<Swift.String>) -> Swift.Void) -> Self
}
@available(*, deprecated, message: "JSONResponseSerializer deprecated and will be removed in Alamofire 6. Use DecodableResponseSerializer instead.")
final public class JSONResponseSerializer : MIBSFramework.ResponseSerializer {
  final public let dataPreprocessor: MIBSFramework.DataPreprocessor
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod>
  final public let options: Foundation.JSONSerialization.ReadingOptions
  public init(dataPreprocessor: MIBSFramework.DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = JSONResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> Any
  public typealias SerializedObject = Any
  @objc deinit
}
extension MIBSFramework.DataRequest {
  @available(*, deprecated, message: "responseJSON deprecated and will be removed in Alamofire 6. Use responseDecodable instead.")
  @discardableResult
  public func responseJSON(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: MIBSFramework.DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = JSONResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments, completionHandler: @escaping (MIBSFramework.AFDataResponse<Any>) -> Swift.Void) -> Self
}
extension MIBSFramework.DownloadRequest {
  @available(*, deprecated, message: "responseJSON deprecated and will be removed in Alamofire 6. Use responseDecodable instead.")
  @discardableResult
  public func responseJSON(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: MIBSFramework.DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = JSONResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments, completionHandler: @escaping (MIBSFramework.AFDownloadResponse<Any>) -> Swift.Void) -> Self
}
public protocol EmptyResponse {
  static func emptyValue() -> Self
}
public struct Empty : Swift.Codable {
  public static let value: MIBSFramework.Empty
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension MIBSFramework.Empty : MIBSFramework.EmptyResponse {
  public static func emptyValue() -> MIBSFramework.Empty
}
public protocol DataDecoder {
  func decode<D>(_ type: D.Type, from data: Foundation.Data) throws -> D where D : Swift.Decodable
}
extension Foundation.JSONDecoder : MIBSFramework.DataDecoder {
}
extension Foundation.PropertyListDecoder : MIBSFramework.DataDecoder {
}
final public class DecodableResponseSerializer<T> : MIBSFramework.ResponseSerializer where T : Swift.Decodable {
  final public let dataPreprocessor: MIBSFramework.DataPreprocessor
  final public let decoder: MIBSFramework.DataDecoder
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod>
  public init(dataPreprocessor: MIBSFramework.DataPreprocessor = DecodableResponseSerializer.defaultDataPreprocessor, decoder: MIBSFramework.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod> = DecodableResponseSerializer.defaultEmptyRequestMethods)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> T
  public typealias SerializedObject = T
  @objc deinit
}
extension MIBSFramework.ResponseSerializer {
  public static func decodable<T>(of type: T.Type, dataPreprocessor: MIBSFramework.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: MIBSFramework.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> MIBSFramework.DecodableResponseSerializer<T> where Self == MIBSFramework.DecodableResponseSerializer<T>, T : Swift.Decodable
}
extension MIBSFramework.DataRequest {
  @discardableResult
  public func responseDecodable<T>(of type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, dataPreprocessor: MIBSFramework.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: MIBSFramework.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods, completionHandler: @escaping (MIBSFramework.AFDataResponse<T>) -> Swift.Void) -> Self where T : Swift.Decodable
}
extension MIBSFramework.DownloadRequest {
  @discardableResult
  public func responseDecodable<T>(of type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, dataPreprocessor: MIBSFramework.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: MIBSFramework.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods, completionHandler: @escaping (MIBSFramework.AFDownloadResponse<T>) -> Swift.Void) -> Self where T : Swift.Decodable
}
public protocol DataStreamSerializer {
  associatedtype SerializedObject
  func serialize(_ data: Foundation.Data) throws -> Self.SerializedObject
}
public struct DecodableStreamSerializer<T> : MIBSFramework.DataStreamSerializer where T : Swift.Decodable {
  public let decoder: MIBSFramework.DataDecoder
  public let dataPreprocessor: MIBSFramework.DataPreprocessor
  public init(decoder: MIBSFramework.DataDecoder = JSONDecoder(), dataPreprocessor: MIBSFramework.DataPreprocessor = PassthroughPreprocessor())
  public func serialize(_ data: Foundation.Data) throws -> T
  public typealias SerializedObject = T
}
public struct PassthroughStreamSerializer : MIBSFramework.DataStreamSerializer {
  public init()
  public func serialize(_ data: Foundation.Data) throws -> Foundation.Data
  public typealias SerializedObject = Foundation.Data
}
public struct StringStreamSerializer : MIBSFramework.DataStreamSerializer {
  public init()
  public func serialize(_ data: Foundation.Data) throws -> Swift.String
  public typealias SerializedObject = Swift.String
}
extension MIBSFramework.DataStreamSerializer {
  public static func decodable<T>(of type: T.Type, decoder: MIBSFramework.DataDecoder = JSONDecoder(), dataPreprocessor: MIBSFramework.DataPreprocessor = PassthroughPreprocessor()) -> Self where Self == MIBSFramework.DecodableStreamSerializer<T>, T : Swift.Decodable
}
extension MIBSFramework.DataStreamSerializer where Self == MIBSFramework.PassthroughStreamSerializer {
  public static var passthrough: MIBSFramework.PassthroughStreamSerializer {
    get
  }
}
extension MIBSFramework.DataStreamSerializer where Self == MIBSFramework.StringStreamSerializer {
  public static var string: MIBSFramework.StringStreamSerializer {
    get
  }
}
extension MIBSFramework.DataStreamRequest {
  @discardableResult
  final public func responseStream(on queue: Dispatch.DispatchQueue = .main, stream: @escaping MIBSFramework.DataStreamRequest.Handler<Foundation.Data, Swift.Never>) -> Self
  @discardableResult
  final public func responseStream<Serializer>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main, stream: @escaping MIBSFramework.DataStreamRequest.Handler<Serializer.SerializedObject, MIBSFramework.AFError>) -> Self where Serializer : MIBSFramework.DataStreamSerializer
  @discardableResult
  final public func responseStreamString(on queue: Dispatch.DispatchQueue = .main, stream: @escaping MIBSFramework.DataStreamRequest.Handler<Swift.String, Swift.Never>) -> Self
  @discardableResult
  final public func responseStreamDecodable<T>(of type: T.Type = T.self, on queue: Dispatch.DispatchQueue = .main, using decoder: MIBSFramework.DataDecoder = JSONDecoder(), preprocessor: MIBSFramework.DataPreprocessor = PassthroughPreprocessor(), stream: @escaping MIBSFramework.DataStreamRequest.Handler<T, MIBSFramework.AFError>) -> Self where T : Swift.Decodable
}
public protocol CachedResponseHandler {
  func dataTask(_ task: Foundation.URLSessionDataTask, willCacheResponse response: Foundation.CachedURLResponse, completion: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
public struct ResponseCacher {
  public enum Behavior {
    case cache
    case doNotCache
    case modify((Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Foundation.CachedURLResponse?)
  }
  public static let cache: MIBSFramework.ResponseCacher
  public static let doNotCache: MIBSFramework.ResponseCacher
  public let behavior: MIBSFramework.ResponseCacher.Behavior
  public init(behavior: MIBSFramework.ResponseCacher.Behavior)
}
extension MIBSFramework.ResponseCacher : MIBSFramework.CachedResponseHandler {
  public func dataTask(_ task: Foundation.URLSessionDataTask, willCacheResponse response: Foundation.CachedURLResponse, completion: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
extension MIBSFramework.CachedResponseHandler where Self == MIBSFramework.ResponseCacher {
  public static var cache: MIBSFramework.ResponseCacher {
    get
  }
  public static var doNotCache: MIBSFramework.ResponseCacher {
    get
  }
  public static func modify(using closure: @escaping ((Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Foundation.CachedURLResponse?)) -> MIBSFramework.ResponseCacher
}
extension Foundation.URLSessionConfiguration : MIBSFramework.AlamofireExtended {
  public typealias ExtendedType = Foundation.URLSessionConfiguration
}
extension MIBSFramework.AlamofireExtension where ExtendedType : Foundation.URLSessionConfiguration {
  public static var `default`: Foundation.URLSessionConfiguration {
    get
  }
  public static var ephemeral: Foundation.URLSessionConfiguration {
    get
  }
}
public struct LottieConfiguration : Swift.Hashable {
  public init(renderingEngine: MIBSFramework.RenderingEngineOption = .mainThread, decodingStrategy: MIBSFramework.DecodingStrategy = .codable)
  public static var shared: MIBSFramework.LottieConfiguration
  public var renderingEngine: MIBSFramework.RenderingEngineOption
  public var decodingStrategy: MIBSFramework.DecodingStrategy
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: MIBSFramework.LottieConfiguration, b: MIBSFramework.LottieConfiguration) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum RenderingEngineOption : Swift.Hashable {
  case automatic
  case specific(MIBSFramework.RenderingEngine)
  public static var mainThread: MIBSFramework.RenderingEngineOption {
    get
  }
  public static var coreAnimation: MIBSFramework.RenderingEngineOption {
    get
  }
}
public enum RenderingEngine : Swift.Hashable {
  case mainThread
  case coreAnimation
}
extension MIBSFramework.RenderingEngineOption : Swift.RawRepresentable, Swift.CustomStringConvertible {
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
extension MIBSFramework.RenderingEngine : Swift.RawRepresentable, Swift.CustomStringConvertible {
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
public enum DecodingStrategy : Swift.Hashable {
  case codable
  case dictionaryBased
  public static func == (a: MIBSFramework.DecodingStrategy, b: MIBSFramework.DecodingStrategy) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOSApplicationExtension, unavailable)
extension MIBSFramework.IQKeyboardManager {
  @objc final public var movedDistance: CoreFoundation.CGFloat {
    @objc get
  }
  @objc final public var movedDistanceChanged: ((CoreFoundation.CGFloat) -> Swift.Void)? {
    @objc get
    @objc set(newValue)
  }
}
@_inheritsConvenienceInitializers @objc public class CardAndBarcodeDetectionSettings : ObjectiveC.NSObject, MIBSFramework.TorchSettings {
  @objc public var torchLevel: Swift.Float
  @objc final public let cardDetectionSettings: MIBSFramework.BaseCardDetectionSettings
  @objc final public let barcodeDetectionSettings: MIBSFramework.BaseBarcodeDetectionSettings
  @objc public init(width: CoreFoundation.CGFloat, height: CoreFoundation.CGFloat, barcodeSymbologies: [Vision.VNBarcodeSymbology]) throws
  @objc override dynamic public init()
  @objc deinit
}
public protocol TextInputFormatter {
  func formatInput(currentText: Swift.String, range: Foundation.NSRange, replacementString text: Swift.String) -> MIBSFramework.FormattedTextValue
}
@_hasMissingDesignatedInitializers public class LightboxConfig {
  public static var hideStatusBar: Swift.Bool
  public static var handleVideo: (_ from: UIKit.UIViewController, _ videoURL: Foundation.URL) -> Swift.Void
  public static var loadImage: (_ imageView: MIBSFramework.SDAnimatedImageView, _ imageURL: Foundation.URL, _ completion: ((UIKit.UIImage?) -> Swift.Void)?) -> Swift.Void
  public static var makeLoadingIndicator: () -> UIKit.UIView
  public static var preload: Swift.Int
  public struct PageIndicator {
    public static var enabled: Swift.Bool
    public static var separatorColor: UIKit.UIColor
    public static var textAttributes: [Foundation.NSAttributedString.Key : Any]
  }
  public struct CloseButton {
    public static var enabled: Swift.Bool
    public static var size: CoreFoundation.CGSize?
    public static var text: Swift.String
    public static var image: UIKit.UIImage?
    public static var textAttributes: [Foundation.NSAttributedString.Key : Any]
  }
  public struct DeleteButton {
    public static var enabled: Swift.Bool
    public static var size: CoreFoundation.CGSize?
    public static var text: Swift.String
    public static var image: UIKit.UIImage?
    public static var textAttributes: [Foundation.NSAttributedString.Key : Any]
  }
  public struct InfoLabel {
    public static var enabled: Swift.Bool
    public static var textColor: UIKit.UIColor
    public static var ellipsisText: Swift.String
    public static var ellipsisColor: UIKit.UIColor
    public static var textAttributes: [Foundation.NSAttributedString.Key : Any]
  }
  public struct Zoom {
    public static var minimumScale: CoreFoundation.CGFloat
    public static var maximumScale: CoreFoundation.CGFloat
  }
  @objc deinit
}
public enum ReachabilityError : Swift.Error {
  case failedToCreateWithAddress(Darwin.sockaddr, Swift.Int32)
  case failedToCreateWithHostname(Swift.String, Swift.Int32)
  case unableToSetCallback(Swift.Int32)
  case unableToSetDispatchQueue(Swift.Int32)
  case unableToGetFlags(Swift.Int32)
}
@available(*, unavailable, renamed: "Notification.Name.reachabilityChanged")
public let ReachabilityChangedNotification: Foundation.NSNotification.Name
extension Foundation.NSNotification.Name {
  public static let reachabilityChanged: Foundation.Notification.Name
}
public class Reachability {
  public typealias NetworkReachable = (MIBSFramework.Reachability) -> ()
  public typealias NetworkUnreachable = (MIBSFramework.Reachability) -> ()
  @available(*, unavailable, renamed: "Connection")
  public enum NetworkStatus : Swift.CustomStringConvertible {
    case notReachable, reachableViaWiFi, reachableViaWWAN
    public var description: Swift.String {
      get
    }
    public static func == (a: MIBSFramework.Reachability.NetworkStatus, b: MIBSFramework.Reachability.NetworkStatus) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Connection : Swift.CustomStringConvertible {
    case unavailable, wifi, cellular
    public var description: Swift.String {
      get
    }
    @available(*, deprecated, renamed: "unavailable")
    public static let none: MIBSFramework.Reachability.Connection
    public static func == (a: MIBSFramework.Reachability.Connection, b: MIBSFramework.Reachability.Connection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var whenReachable: MIBSFramework.Reachability.NetworkReachable?
  public var whenUnreachable: MIBSFramework.Reachability.NetworkUnreachable?
  @available(*, deprecated, renamed: "allowsCellularConnection")
  final public let reachableOnWWAN: Swift.Bool
  public var allowsCellularConnection: Swift.Bool
  public var notificationCenter: Foundation.NotificationCenter
  @available(*, deprecated, renamed: "connection.description")
  public var currentReachabilityString: Swift.String {
    get
  }
  @available(*, unavailable, renamed: "connection")
  public var currentReachabilityStatus: MIBSFramework.Reachability.Connection {
    get
  }
  public var connection: MIBSFramework.Reachability.Connection {
    get
  }
  required public init(reachabilityRef: SystemConfiguration.SCNetworkReachability, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main)
  convenience public init(hostname: Swift.String, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  convenience public init(queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  @objc deinit
}
extension MIBSFramework.Reachability {
  public func startNotifier() throws
  public func stopNotifier()
  @available(*, deprecated, message: "Please use `connection != .none`")
  public var isReachable: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .cellular`")
  public var isReachableViaWWAN: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .wifi`")
  public var isReachableViaWiFi: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
}
public protocol DPOTPViewDelegate {
  func dpOTPViewAddText(_ text: Swift.String, at position: Swift.Int)
  func dpOTPViewRemoveText(_ text: Swift.String, at position: Swift.Int)
  func dpOTPViewChangePositionAt(_ position: Swift.Int)
  func dpOTPViewBecomeFirstResponder()
  func dpOTPViewResignFirstResponder()
}
@objc @_inheritsConvenienceInitializers @IBDesignable @_Concurrency.MainActor(unsafe) open class DPOTPView : UIKit.UIView {
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var count: Swift.Int {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var spacing: CoreFoundation.CGFloat
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var textColorTextField: UIKit.UIColor
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var fontTextField: UIKit.UIFont
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var placeholder: Swift.String
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var placeholderTextColor: UIKit.UIColor
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var isCircleTextField: Swift.Bool
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var isBottomLineTextField: Swift.Bool
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var backGroundImageTextField: UIKit.UIImage?
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var backGroundColorTextField: UIKit.UIColor
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var backGroundColorFilledTextField: UIKit.UIColor?
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var borderColorTextField: UIKit.UIColor?
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var selectedBorderColorTextField: UIKit.UIColor?
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var borderWidthTextField: CoreFoundation.CGFloat
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var selectedBorderWidthTextField: CoreFoundation.CGFloat
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var cornerRadiusTextField: CoreFoundation.CGFloat
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var tintColorTextField: UIKit.UIColor
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var shadowRadiusTextField: CoreFoundation.CGFloat
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var shadowOpacityTextField: Swift.Float
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var shadowOffsetSizeTextField: CoreFoundation.CGSize
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var shadowColorTextField: UIKit.UIColor?
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var dismissOnLastEntry: Swift.Bool
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var isSecureTextEntry: Swift.Bool
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var isCursorHidden: Swift.Bool
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic open var isDarkKeyboard: Swift.Bool
  @_Concurrency.MainActor(unsafe) dynamic open var textEdgeInsets: UIKit.UIEdgeInsets?
  @_Concurrency.MainActor(unsafe) dynamic open var editingTextEdgeInsets: UIKit.UIEdgeInsets?
  @_Concurrency.MainActor(unsafe) dynamic open var inputViewForAll: UIKit.UIView?
  @_Concurrency.MainActor(unsafe) dynamic open var inputAccessoryViewForAll: UIKit.UIView?
  @_Concurrency.MainActor(unsafe) dynamic open var dpOTPViewDelegate: MIBSFramework.DPOTPViewDelegate?
  @_Concurrency.MainActor(unsafe) dynamic open var keyboardType: UIKit.UIKeyboardType
  @_Concurrency.MainActor(unsafe) dynamic open var text: Swift.String? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func prepareForInterfaceBuilder()
  @discardableResult
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func becomeFirstResponder() -> Swift.Bool
  @discardableResult
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func resignFirstResponder() -> Swift.Bool
  @_Concurrency.MainActor(unsafe) open func validate() -> Swift.Bool
  @objc deinit
}
extension MIBSFramework.DPOTPView : UIKit.UITextFieldDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textFieldDidBeginEditing(_ textField: UIKit.UITextField)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textField(_ textField: UIKit.UITextField, shouldChangeCharactersIn range: Foundation.NSRange, replacementString string: Swift.String) -> Swift.Bool
}
extension MIBSFramework.Vector1D : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct Vector2D : Swift.Codable, Swift.Hashable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: MIBSFramework.Vector2D, b: MIBSFramework.Vector2D) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension MIBSFramework.Vector3D : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension MIBSFramework.Vector3D {
  public var pointValue: CoreFoundation.CGPoint {
    get
  }
  public var sizeValue: CoreFoundation.CGSize {
    get
  }
}
extension CoreVideo.CVBuffer {
  @available(iOS 13.0, *)
  public func sharpness() -> Swift.Float?
  public func cgImage(withOrientation orientation: ImageIO.CGImagePropertyOrientation) -> CoreGraphics.CGImage?
}
extension CoreMedia.CMSampleBuffer {
  public func cgImage(withOrientation orientation: ImageIO.CGImagePropertyOrientation) -> CoreGraphics.CGImage?
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOSApplicationExtension, unavailable)
@objc @_Concurrency.MainActor(unsafe) open class IQToolbar : UIKit.UIToolbar, UIKit.UIInputViewAudioFeedback {
  @objc @_Concurrency.MainActor(unsafe) open var previousBarButton: MIBSFramework.IQBarButtonItem {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) open var nextBarButton: MIBSFramework.IQBarButtonItem {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) open var titleBarButton: MIBSFramework.IQTitleBarButtonItem {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) open var doneBarButton: MIBSFramework.IQBarButtonItem {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) open var fixedSpaceBarButton: MIBSFramework.IQBarButtonItem {
    @objc get
    @objc set(newValue)
  }
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func sizeThatFits(_ size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var tintColor: UIKit.UIColor! {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc open var enableInputClicksWhenVisible: Swift.Bool {
    @objc get
  }
  @objc deinit
}
@objc @available(iOS 11.0, *)
public class PerspectiveCorrectionParamsOperation : Foundation.Operation {
  public init(pixelBuffer: CoreVideo.CVImageBuffer, orientation: ImageIO.CGImagePropertyOrientation, rect: Vision.VNRectangleObservation)
  @objc override dynamic public func main()
  @objc deinit
}
open class CodableTransform<T> : MIBSFramework.TransformType where T : Swift.Decodable, T : Swift.Encodable {
  public typealias Object = T
  public typealias JSON = Any
  public init()
  open func transformFromJSON(_ value: Any?) -> MIBSFramework.CodableTransform<T>.Object?
  open func transformToJSON(_ value: T?) -> MIBSFramework.CodableTransform<T>.JSON?
  @objc deinit
}
open class Session {
  public static let `default`: MIBSFramework.Session
  final public let session: Foundation.URLSession
  final public let delegate: MIBSFramework.SessionDelegate
  final public let rootQueue: Dispatch.DispatchQueue
  final public let startRequestsImmediately: Swift.Bool
  final public let requestQueue: Dispatch.DispatchQueue
  final public let serializationQueue: Dispatch.DispatchQueue
  final public let interceptor: MIBSFramework.RequestInterceptor?
  final public let serverTrustManager: MIBSFramework.ServerTrustManager?
  final public let redirectHandler: MIBSFramework.RedirectHandler?
  final public let cachedResponseHandler: MIBSFramework.CachedResponseHandler?
  final public let eventMonitor: MIBSFramework.CompositeEventMonitor
  final public let defaultEventMonitors: [MIBSFramework.EventMonitor]
  public init(session: Foundation.URLSession, delegate: MIBSFramework.SessionDelegate, rootQueue: Dispatch.DispatchQueue, startRequestsImmediately: Swift.Bool = true, requestQueue: Dispatch.DispatchQueue? = nil, serializationQueue: Dispatch.DispatchQueue? = nil, interceptor: MIBSFramework.RequestInterceptor? = nil, serverTrustManager: MIBSFramework.ServerTrustManager? = nil, redirectHandler: MIBSFramework.RedirectHandler? = nil, cachedResponseHandler: MIBSFramework.CachedResponseHandler? = nil, eventMonitors: [MIBSFramework.EventMonitor] = [])
  convenience public init(configuration: Foundation.URLSessionConfiguration = URLSessionConfiguration.af.default, delegate: MIBSFramework.SessionDelegate = SessionDelegate(), rootQueue: Dispatch.DispatchQueue = DispatchQueue(label: "org.alamofire.session.rootQueue"), startRequestsImmediately: Swift.Bool = true, requestQueue: Dispatch.DispatchQueue? = nil, serializationQueue: Dispatch.DispatchQueue? = nil, interceptor: MIBSFramework.RequestInterceptor? = nil, serverTrustManager: MIBSFramework.ServerTrustManager? = nil, redirectHandler: MIBSFramework.RedirectHandler? = nil, cachedResponseHandler: MIBSFramework.CachedResponseHandler? = nil, eventMonitors: [MIBSFramework.EventMonitor] = [])
  @objc deinit
  public func withAllRequests(perform action: @escaping (Swift.Set<MIBSFramework.Request>) -> Swift.Void)
  public func cancelAllRequests(completingOnQueue queue: Dispatch.DispatchQueue = .main, completion: (() -> Swift.Void)? = nil)
  public typealias RequestModifier = (inout Foundation.URLRequest) throws -> Swift.Void
  open func request(_ convertible: MIBSFramework.URLConvertible, method: MIBSFramework.HTTPMethod = .get, parameters: MIBSFramework.Parameters? = nil, encoding: MIBSFramework.ParameterEncoding = URLEncoding.default, headers: MIBSFramework.HTTPHeaders? = nil, interceptor: MIBSFramework.RequestInterceptor? = nil, requestModifier: MIBSFramework.Session.RequestModifier? = nil) -> MIBSFramework.DataRequest
  open func request<Parameters>(_ convertible: MIBSFramework.URLConvertible, method: MIBSFramework.HTTPMethod = .get, parameters: Parameters? = nil, encoder: MIBSFramework.ParameterEncoder = URLEncodedFormParameterEncoder.default, headers: MIBSFramework.HTTPHeaders? = nil, interceptor: MIBSFramework.RequestInterceptor? = nil, requestModifier: MIBSFramework.Session.RequestModifier? = nil) -> MIBSFramework.DataRequest where Parameters : Swift.Encodable
  open func request(_ convertible: MIBSFramework.URLRequestConvertible, interceptor: MIBSFramework.RequestInterceptor? = nil) -> MIBSFramework.DataRequest
  open func streamRequest<Parameters>(_ convertible: MIBSFramework.URLConvertible, method: MIBSFramework.HTTPMethod = .get, parameters: Parameters? = nil, encoder: MIBSFramework.ParameterEncoder = URLEncodedFormParameterEncoder.default, headers: MIBSFramework.HTTPHeaders? = nil, automaticallyCancelOnStreamError: Swift.Bool = false, interceptor: MIBSFramework.RequestInterceptor? = nil, requestModifier: MIBSFramework.Session.RequestModifier? = nil) -> MIBSFramework.DataStreamRequest where Parameters : Swift.Encodable
  open func streamRequest(_ convertible: MIBSFramework.URLConvertible, method: MIBSFramework.HTTPMethod = .get, headers: MIBSFramework.HTTPHeaders? = nil, automaticallyCancelOnStreamError: Swift.Bool = false, interceptor: MIBSFramework.RequestInterceptor? = nil, requestModifier: MIBSFramework.Session.RequestModifier? = nil) -> MIBSFramework.DataStreamRequest
  open func streamRequest(_ convertible: MIBSFramework.URLRequestConvertible, automaticallyCancelOnStreamError: Swift.Bool = false, interceptor: MIBSFramework.RequestInterceptor? = nil) -> MIBSFramework.DataStreamRequest
  open func download(_ convertible: MIBSFramework.URLConvertible, method: MIBSFramework.HTTPMethod = .get, parameters: MIBSFramework.Parameters? = nil, encoding: MIBSFramework.ParameterEncoding = URLEncoding.default, headers: MIBSFramework.HTTPHeaders? = nil, interceptor: MIBSFramework.RequestInterceptor? = nil, requestModifier: MIBSFramework.Session.RequestModifier? = nil, to destination: MIBSFramework.DownloadRequest.Destination? = nil) -> MIBSFramework.DownloadRequest
  open func download<Parameters>(_ convertible: MIBSFramework.URLConvertible, method: MIBSFramework.HTTPMethod = .get, parameters: Parameters? = nil, encoder: MIBSFramework.ParameterEncoder = URLEncodedFormParameterEncoder.default, headers: MIBSFramework.HTTPHeaders? = nil, interceptor: MIBSFramework.RequestInterceptor? = nil, requestModifier: MIBSFramework.Session.RequestModifier? = nil, to destination: MIBSFramework.DownloadRequest.Destination? = nil) -> MIBSFramework.DownloadRequest where Parameters : Swift.Encodable
  open func download(_ convertible: MIBSFramework.URLRequestConvertible, interceptor: MIBSFramework.RequestInterceptor? = nil, to destination: MIBSFramework.DownloadRequest.Destination? = nil) -> MIBSFramework.DownloadRequest
  open func download(resumingWith data: Foundation.Data, interceptor: MIBSFramework.RequestInterceptor? = nil, to destination: MIBSFramework.DownloadRequest.Destination? = nil) -> MIBSFramework.DownloadRequest
  open func upload(_ data: Foundation.Data, to convertible: MIBSFramework.URLConvertible, method: MIBSFramework.HTTPMethod = .post, headers: MIBSFramework.HTTPHeaders? = nil, interceptor: MIBSFramework.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: MIBSFramework.Session.RequestModifier? = nil) -> MIBSFramework.UploadRequest
  open func upload(_ data: Foundation.Data, with convertible: MIBSFramework.URLRequestConvertible, interceptor: MIBSFramework.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> MIBSFramework.UploadRequest
  open func upload(_ fileURL: Foundation.URL, to convertible: MIBSFramework.URLConvertible, method: MIBSFramework.HTTPMethod = .post, headers: MIBSFramework.HTTPHeaders? = nil, interceptor: MIBSFramework.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: MIBSFramework.Session.RequestModifier? = nil) -> MIBSFramework.UploadRequest
  open func upload(_ fileURL: Foundation.URL, with convertible: MIBSFramework.URLRequestConvertible, interceptor: MIBSFramework.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> MIBSFramework.UploadRequest
  open func upload(_ stream: Foundation.InputStream, to convertible: MIBSFramework.URLConvertible, method: MIBSFramework.HTTPMethod = .post, headers: MIBSFramework.HTTPHeaders? = nil, interceptor: MIBSFramework.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: MIBSFramework.Session.RequestModifier? = nil) -> MIBSFramework.UploadRequest
  open func upload(_ stream: Foundation.InputStream, with convertible: MIBSFramework.URLRequestConvertible, interceptor: MIBSFramework.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> MIBSFramework.UploadRequest
  open func upload(multipartFormData: @escaping (MIBSFramework.MultipartFormData) -> Swift.Void, to url: MIBSFramework.URLConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = MultipartFormData.encodingMemoryThreshold, method: MIBSFramework.HTTPMethod = .post, headers: MIBSFramework.HTTPHeaders? = nil, interceptor: MIBSFramework.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: MIBSFramework.Session.RequestModifier? = nil) -> MIBSFramework.UploadRequest
  open func upload(multipartFormData: @escaping (MIBSFramework.MultipartFormData) -> Swift.Void, with request: MIBSFramework.URLRequestConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = MultipartFormData.encodingMemoryThreshold, interceptor: MIBSFramework.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> MIBSFramework.UploadRequest
  open func upload(multipartFormData: MIBSFramework.MultipartFormData, to url: MIBSFramework.URLConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = MultipartFormData.encodingMemoryThreshold, method: MIBSFramework.HTTPMethod = .post, headers: MIBSFramework.HTTPHeaders? = nil, interceptor: MIBSFramework.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: MIBSFramework.Session.RequestModifier? = nil) -> MIBSFramework.UploadRequest
  open func upload(multipartFormData: MIBSFramework.MultipartFormData, with request: MIBSFramework.URLRequestConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = MultipartFormData.encodingMemoryThreshold, interceptor: MIBSFramework.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> MIBSFramework.UploadRequest
}
extension MIBSFramework.Session : MIBSFramework.RequestDelegate {
  public var sessionConfiguration: Foundation.URLSessionConfiguration {
    get
  }
  public var startImmediately: Swift.Bool {
    get
  }
  public func cleanup(after request: MIBSFramework.Request)
  public func retryResult(for request: MIBSFramework.Request, dueTo error: MIBSFramework.AFError, completion: @escaping (MIBSFramework.RetryResult) -> Swift.Void)
  public func retryRequest(_ request: MIBSFramework.Request, withDelay timeDelay: Foundation.TimeInterval?)
}
public func <- <T>(left: inout T, right: MIBSFramework.Map) where T : Swift.RawRepresentable
public func >>> <T>(left: T, right: MIBSFramework.Map) where T : Swift.RawRepresentable
public func <- <T>(left: inout T?, right: MIBSFramework.Map) where T : Swift.RawRepresentable
public func >>> <T>(left: T?, right: MIBSFramework.Map) where T : Swift.RawRepresentable
public func <- <T>(left: inout [T], right: MIBSFramework.Map) where T : Swift.RawRepresentable
public func >>> <T>(left: [T], right: MIBSFramework.Map) where T : Swift.RawRepresentable
public func <- <T>(left: inout [T]?, right: MIBSFramework.Map) where T : Swift.RawRepresentable
public func >>> <T>(left: [T]?, right: MIBSFramework.Map) where T : Swift.RawRepresentable
public func <- <T>(left: inout [Swift.String : T], right: MIBSFramework.Map) where T : Swift.RawRepresentable
public func >>> <T>(left: [Swift.String : T], right: MIBSFramework.Map) where T : Swift.RawRepresentable
public func <- <T>(left: inout [Swift.String : T]?, right: MIBSFramework.Map) where T : Swift.RawRepresentable
public func >>> <T>(left: [Swift.String : T]?, right: MIBSFramework.Map) where T : Swift.RawRepresentable
public enum LayerType : Swift.Int, Swift.Codable {
  case precomp
  case solid
  case image
  case null
  case shape
  case text
  public init(from decoder: Swift.Decoder) throws
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum MatteType : Swift.Int, Swift.Codable {
  case none
  case add
  case invert
  case unknown
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum BlendMode : Swift.Int, Swift.Codable {
  case normal
  case multiply
  case screen
  case overlay
  case darken
  case lighten
  case colorDodge
  case colorBurn
  case hardLight
  case softLight
  case difference
  case exclusion
  case hue
  case saturation
  case color
  case luminosity
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public class LRUAnimationCache : MIBSFramework.AnimationCacheProvider {
  public init()
  public static let sharedCache: MIBSFramework.LRUAnimationCache
  public var cacheSize: Swift.Int
  public func clearCache()
  public func animation(forKey: Swift.String) -> MIBSFramework.Animation?
  public func setAnimation(_ animation: MIBSFramework.Animation, forKey: Swift.String)
  @objc deinit
}
open class DateFormatterTransform : MIBSFramework.TransformType {
  public typealias Object = Foundation.Date
  public typealias JSON = Swift.String
  final public let dateFormatter: Foundation.DateFormatter
  public init(dateFormatter: Foundation.DateFormatter)
  open func transformFromJSON(_ value: Any?) -> Foundation.Date?
  open func transformToJSON(_ value: Foundation.Date?) -> Swift.String?
  @objc deinit
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
public struct DataResponsePublisher<Value> : Combine.Publisher {
  public typealias Output = MIBSFramework.DataResponse<Value, MIBSFramework.AFError>
  public typealias Failure = Swift.Never
  public init<Serializer>(_ request: MIBSFramework.DataRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : MIBSFramework.ResponseSerializer
  public init<Serializer>(_ request: MIBSFramework.DataRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : MIBSFramework.DataResponseSerializerProtocol
  public func result() -> Combine.AnyPublisher<Swift.Result<Value, MIBSFramework.AFError>, Swift.Never>
  public func value() -> Combine.AnyPublisher<Value, MIBSFramework.AFError>
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == MIBSFramework.DataResponse<Value, MIBSFramework.AFError>
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
extension MIBSFramework.DataResponsePublisher where Value == Foundation.Data? {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public init(_ request: MIBSFramework.DataRequest, queue: Dispatch.DispatchQueue)
}
extension MIBSFramework.DataRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishResponse<Serializer, T>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> MIBSFramework.DataResponsePublisher<T> where Serializer : MIBSFramework.ResponseSerializer, T == Serializer.SerializedObject
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishData(queue: Dispatch.DispatchQueue = .main, preprocessor: MIBSFramework.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> MIBSFramework.DataResponsePublisher<Foundation.Data>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishString(queue: Dispatch.DispatchQueue = .main, preprocessor: MIBSFramework.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> MIBSFramework.DataResponsePublisher<Swift.String>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  @available(*, deprecated, message: "Renamed publishDecodable(type:queue:preprocessor:decoder:emptyResponseCodes:emptyRequestMethods).")
  @_disfavoredOverload public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: MIBSFramework.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: MIBSFramework.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyResponseMethods: Swift.Set<MIBSFramework.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> MIBSFramework.DataResponsePublisher<T> where T : Swift.Decodable
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: MIBSFramework.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: MIBSFramework.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> MIBSFramework.DataResponsePublisher<T> where T : Swift.Decodable
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishUnserialized(queue: Dispatch.DispatchQueue = .main) -> MIBSFramework.DataResponsePublisher<Foundation.Data?>
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
public struct DataStreamPublisher<Value> : Combine.Publisher {
  public typealias Output = MIBSFramework.DataStreamRequest.Stream<Value, MIBSFramework.AFError>
  public typealias Failure = Swift.Never
  public init<Serializer>(_ request: MIBSFramework.DataStreamRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : MIBSFramework.DataStreamSerializer
  public func result() -> Combine.AnyPublisher<Swift.Result<Value, MIBSFramework.AFError>, Swift.Never>
  public func value() -> Combine.AnyPublisher<Value, MIBSFramework.AFError>
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == MIBSFramework.DataStreamRequest.Stream<Value, MIBSFramework.AFError>
}
extension MIBSFramework.DataStreamRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishStream<Serializer>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> MIBSFramework.DataStreamPublisher<Serializer.SerializedObject> where Serializer : MIBSFramework.DataStreamSerializer
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishData(queue: Dispatch.DispatchQueue = .main) -> MIBSFramework.DataStreamPublisher<Foundation.Data>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishString(queue: Dispatch.DispatchQueue = .main) -> MIBSFramework.DataStreamPublisher<Swift.String>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, decoder: MIBSFramework.DataDecoder = JSONDecoder(), preprocessor: MIBSFramework.DataPreprocessor = PassthroughPreprocessor()) -> MIBSFramework.DataStreamPublisher<T> where T : Swift.Decodable
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
public struct DownloadResponsePublisher<Value> : Combine.Publisher {
  public typealias Output = MIBSFramework.DownloadResponse<Value, MIBSFramework.AFError>
  public typealias Failure = Swift.Never
  public init<Serializer>(_ request: MIBSFramework.DownloadRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : MIBSFramework.ResponseSerializer
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public init<Serializer>(_ request: MIBSFramework.DownloadRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : MIBSFramework.DownloadResponseSerializerProtocol
  public func result() -> Combine.AnyPublisher<Swift.Result<Value, MIBSFramework.AFError>, Swift.Never>
  public func value() -> Combine.AnyPublisher<Value, MIBSFramework.AFError>
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == MIBSFramework.DownloadResponse<Value, MIBSFramework.AFError>
}
extension MIBSFramework.DownloadRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishResponse<Serializer, T>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> MIBSFramework.DownloadResponsePublisher<T> where Serializer : MIBSFramework.ResponseSerializer, T == Serializer.SerializedObject
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishResponse<Serializer, T>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> MIBSFramework.DownloadResponsePublisher<T> where Serializer : MIBSFramework.DownloadResponseSerializerProtocol, T == Serializer.SerializedObject
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishURL(queue: Dispatch.DispatchQueue = .main) -> MIBSFramework.DownloadResponsePublisher<Foundation.URL>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishData(queue: Dispatch.DispatchQueue = .main, preprocessor: MIBSFramework.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> MIBSFramework.DownloadResponsePublisher<Foundation.Data>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishString(queue: Dispatch.DispatchQueue = .main, preprocessor: MIBSFramework.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> MIBSFramework.DownloadResponsePublisher<Swift.String>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  @available(*, deprecated, message: "Renamed publishDecodable(type:queue:preprocessor:decoder:emptyResponseCodes:emptyRequestMethods).")
  @_disfavoredOverload public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: MIBSFramework.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: MIBSFramework.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyResponseMethods: Swift.Set<MIBSFramework.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> MIBSFramework.DownloadResponsePublisher<T> where T : Swift.Decodable
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: MIBSFramework.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: MIBSFramework.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> MIBSFramework.DownloadResponsePublisher<T> where T : Swift.Decodable
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
extension MIBSFramework.DownloadResponsePublisher where Value == Foundation.URL? {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public init(_ request: MIBSFramework.DownloadRequest, queue: Dispatch.DispatchQueue)
}
extension MIBSFramework.DownloadRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishUnserialized(on queue: Dispatch.DispatchQueue = .main) -> MIBSFramework.DownloadResponsePublisher<Foundation.URL?>
}
@_inheritsConvenienceInitializers @available(iOSApplicationExtension, unavailable)
@objc @_Concurrency.MainActor(unsafe) open class IQPreviousNextView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public protocol TextFormatter {
  func format(_ unformattedText: Swift.String?) -> Swift.String?
}
public protocol MapContext {
}
final public class Map {
  final public let mappingType: MIBSFramework.MappingType
  final public var JSON: [Swift.String : Any] {
    get
  }
  final public var isKeyPresent: Swift.Bool {
    get
  }
  final public var currentValue: Any? {
    get
  }
  final public var currentKey: Swift.String? {
    get
  }
  final public var nestedKeyDelimiter: Swift.String {
    get
  }
  final public var context: MIBSFramework.MapContext?
  final public var shouldIncludeNilValues: Swift.Bool
  final public let toObject: Swift.Bool
  public init(mappingType: MIBSFramework.MappingType, JSON: [Swift.String : Any], toObject: Swift.Bool = false, context: MIBSFramework.MapContext? = nil, shouldIncludeNilValues: Swift.Bool = false)
  final public subscript(key: Swift.String) -> MIBSFramework.Map {
    get
  }
  final public subscript(key: Swift.String, delimiter delimiter: Swift.String) -> MIBSFramework.Map {
    get
  }
  final public subscript(key: Swift.String, nested nested: Swift.Bool) -> MIBSFramework.Map {
    get
  }
  final public subscript(key: Swift.String, nested nested: Swift.Bool, delimiter delimiter: Swift.String) -> MIBSFramework.Map {
    get
  }
  final public subscript(key: Swift.String, ignoreNil ignoreNil: Swift.Bool) -> MIBSFramework.Map {
    get
  }
  final public subscript(key: Swift.String, delimiter delimiter: Swift.String, ignoreNil ignoreNil: Swift.Bool) -> MIBSFramework.Map {
    get
  }
  final public subscript(key: Swift.String, nested nested: Swift.Bool, ignoreNil ignoreNil: Swift.Bool) -> MIBSFramework.Map {
    get
  }
  final public subscript(key: Swift.String, nested nested: Swift.Bool?, delimiter delimiter: Swift.String, ignoreNil ignoreNil: Swift.Bool) -> MIBSFramework.Map {
    get
  }
  final public func value<T>() -> T?
  @objc deinit
}
extension MIBSFramework.Map {
  final public func value<T>(_ key: Swift.String, default: T.Object, using transform: T) throws -> T.Object where T : MIBSFramework.TransformType
  final public func value<T>(_ key: Swift.String, default: T) throws -> T
  final public func value<T>(_ key: Swift.String, default: [T]) -> [T] where T : MIBSFramework.BaseMappable
  final public func value<T>(_ key: Swift.String, default: T) throws -> T where T : MIBSFramework.BaseMappable
}
open class ServerTrustManager {
  final public let allHostsMustBeEvaluated: Swift.Bool
  final public let evaluators: [Swift.String : MIBSFramework.ServerTrustEvaluating]
  public init(allHostsMustBeEvaluated: Swift.Bool = true, evaluators: [Swift.String : MIBSFramework.ServerTrustEvaluating])
  open func serverTrustEvaluator(forHost host: Swift.String) throws -> MIBSFramework.ServerTrustEvaluating?
  @objc deinit
}
public protocol ServerTrustEvaluating {
  func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
}
final public class DefaultTrustEvaluator : MIBSFramework.ServerTrustEvaluating {
  public init(validateHost: Swift.Bool = true)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
final public class RevocationTrustEvaluator : MIBSFramework.ServerTrustEvaluating {
  public struct Options : Swift.OptionSet {
    public static let crl: MIBSFramework.RevocationTrustEvaluator.Options
    public static let networkAccessDisabled: MIBSFramework.RevocationTrustEvaluator.Options
    public static let ocsp: MIBSFramework.RevocationTrustEvaluator.Options
    public static let preferCRL: MIBSFramework.RevocationTrustEvaluator.Options
    public static let requirePositiveResponse: MIBSFramework.RevocationTrustEvaluator.Options
    public static let any: MIBSFramework.RevocationTrustEvaluator.Options
    public let rawValue: CoreFoundation.CFOptionFlags
    public init(rawValue: CoreFoundation.CFOptionFlags)
    public typealias ArrayLiteralElement = MIBSFramework.RevocationTrustEvaluator.Options
    public typealias Element = MIBSFramework.RevocationTrustEvaluator.Options
    public typealias RawValue = CoreFoundation.CFOptionFlags
  }
  public init(performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true, options: MIBSFramework.RevocationTrustEvaluator.Options = .any)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension MIBSFramework.ServerTrustEvaluating where Self == MIBSFramework.RevocationTrustEvaluator {
  public static var revocationChecking: MIBSFramework.RevocationTrustEvaluator {
    get
  }
  public static func revocationChecking(performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true, options: MIBSFramework.RevocationTrustEvaluator.Options = .any) -> MIBSFramework.RevocationTrustEvaluator
}
final public class PinnedCertificatesTrustEvaluator : MIBSFramework.ServerTrustEvaluating {
  public init(certificates: [Security.SecCertificate] = Bundle.main.af.certificates, acceptSelfSignedCertificates: Swift.Bool = false, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension MIBSFramework.ServerTrustEvaluating where Self == MIBSFramework.PinnedCertificatesTrustEvaluator {
  public static var pinnedCertificates: MIBSFramework.PinnedCertificatesTrustEvaluator {
    get
  }
  public static func pinnedCertificates(certificates: [Security.SecCertificate] = Bundle.main.af.certificates, acceptSelfSignedCertificates: Swift.Bool = false, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true) -> MIBSFramework.PinnedCertificatesTrustEvaluator
}
final public class PublicKeysTrustEvaluator : MIBSFramework.ServerTrustEvaluating {
  public init(keys: [Security.SecKey] = Bundle.main.af.publicKeys, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension MIBSFramework.ServerTrustEvaluating where Self == MIBSFramework.PublicKeysTrustEvaluator {
  public static var publicKeys: MIBSFramework.PublicKeysTrustEvaluator {
    get
  }
  public static func publicKeys(keys: [Security.SecKey] = Bundle.main.af.publicKeys, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true) -> MIBSFramework.PublicKeysTrustEvaluator
}
final public class CompositeTrustEvaluator : MIBSFramework.ServerTrustEvaluating {
  public init(evaluators: [MIBSFramework.ServerTrustEvaluating])
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension MIBSFramework.ServerTrustEvaluating where Self == MIBSFramework.CompositeTrustEvaluator {
  public static func composite(evaluators: [MIBSFramework.ServerTrustEvaluating]) -> MIBSFramework.CompositeTrustEvaluator
}
@available(*, deprecated, renamed: "DisabledTrustEvaluator", message: "DisabledEvaluator has been renamed DisabledTrustEvaluator.")
public typealias DisabledEvaluator = MIBSFramework.DisabledTrustEvaluator
final public class DisabledTrustEvaluator : MIBSFramework.ServerTrustEvaluating {
  public init()
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension Swift.Array where Element == MIBSFramework.ServerTrustEvaluating {
  public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
}
extension Foundation.Bundle : MIBSFramework.AlamofireExtended {
  public typealias ExtendedType = Foundation.Bundle
}
extension MIBSFramework.AlamofireExtension where ExtendedType : Foundation.Bundle {
  public var certificates: [Security.SecCertificate] {
    get
  }
  public var publicKeys: [Security.SecKey] {
    get
  }
  public func paths(forResourcesOfTypes types: [Swift.String]) -> [Swift.String]
}
extension Security.SecTrust : MIBSFramework.AlamofireExtended {
  public typealias ExtendedType = Security.SecTrust
}
extension MIBSFramework.AlamofireExtension where ExtendedType == Security.SecTrust {
  @available(iOS 12, macOS 10.14, tvOS 12, watchOS 5, *)
  public func evaluate(afterApplying policy: Security.SecPolicy) throws
  @available(iOS, introduced: 10, deprecated: 12, renamed: "evaluate(afterApplying:)")
  @available(macOS, introduced: 10.12, deprecated: 10.14, renamed: "evaluate(afterApplying:)")
  @available(tvOS, introduced: 10, deprecated: 12, renamed: "evaluate(afterApplying:)")
  @available(watchOS, introduced: 3, deprecated: 5, renamed: "evaluate(afterApplying:)")
  public func validate(policy: Security.SecPolicy, errorProducer: (_ status: Darwin.OSStatus, _ result: Security.SecTrustResultType) -> Swift.Error) throws
  public func apply(policy: Security.SecPolicy) throws -> Security.SecTrust
  @available(iOS 12, macOS 10.14, tvOS 12, watchOS 5, *)
  public func evaluate() throws
  @available(iOS, introduced: 10, deprecated: 12, renamed: "evaluate()")
  @available(macOS, introduced: 10.12, deprecated: 10.14, renamed: "evaluate()")
  @available(tvOS, introduced: 10, deprecated: 12, renamed: "evaluate()")
  @available(watchOS, introduced: 3, deprecated: 5, renamed: "evaluate()")
  public func validate(errorProducer: (_ status: Darwin.OSStatus, _ result: Security.SecTrustResultType) -> Swift.Error) throws
  public func setAnchorCertificates(_ certificates: [Security.SecCertificate]) throws
  public var publicKeys: [Security.SecKey] {
    get
  }
  public var certificates: [Security.SecCertificate] {
    get
  }
  public var certificateData: [Foundation.Data] {
    get
  }
  public func performDefaultValidation(forHost host: Swift.String) throws
  public func performValidation(forHost host: Swift.String) throws
}
extension Security.SecPolicy : MIBSFramework.AlamofireExtended {
  public typealias ExtendedType = Security.SecPolicy
}
extension MIBSFramework.AlamofireExtension where ExtendedType == Security.SecPolicy {
  public static let `default`: Security.SecPolicy
  public static func hostname(_ hostname: Swift.String) -> Security.SecPolicy
  public static func revocation(options: MIBSFramework.RevocationTrustEvaluator.Options) throws -> Security.SecPolicy
}
extension Swift.Array : MIBSFramework.AlamofireExtended {
  public typealias ExtendedType = Swift.Array<Element>
}
extension MIBSFramework.AlamofireExtension where ExtendedType == [Security.SecCertificate] {
  public var data: [Foundation.Data] {
    get
  }
  public var publicKeys: [Security.SecKey] {
    get
  }
}
extension Security.SecCertificate : MIBSFramework.AlamofireExtended {
  public typealias ExtendedType = Security.SecCertificate
}
extension MIBSFramework.AlamofireExtension where ExtendedType == Security.SecCertificate {
  public var publicKey: Security.SecKey? {
    get
  }
}
extension Swift.Int32 : MIBSFramework.AlamofireExtended {
  public typealias ExtendedType = Swift.Int32
}
extension MIBSFramework.AlamofireExtension where ExtendedType == Swift.Int32 {
  public var isSuccess: Swift.Bool {
    get
  }
}
extension Security.SecTrustResultType : MIBSFramework.AlamofireExtended {
  public typealias ExtendedType = Security.SecTrustResultType
}
extension MIBSFramework.AlamofireExtension where ExtendedType == Security.SecTrustResultType {
  public var isSuccess: Swift.Bool {
    get
  }
}
final public class PointValueProvider {
  public init(block: @escaping MIBSFramework.PointValueProvider.PointValueBlock)
  public init(_ point: CoreFoundation.CGPoint)
  public typealias PointValueBlock = (CoreFoundation.CGFloat) -> CoreFoundation.CGPoint
  final public var point: CoreFoundation.CGPoint {
    get
    set
  }
  final public var valueType: Any.Type {
    get
  }
  final public var storage: MIBSFramework.ValueProviderStorage<MIBSFramework.Vector3D> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
public func <- <Transform>(left: inout Transform.Object, right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType
public func >>> <Transform>(left: Transform.Object, right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType
public func <- <Transform>(left: inout Transform.Object?, right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType
public func >>> <Transform>(left: Transform.Object?, right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType
public func <- <Transform>(left: inout [Transform.Object], right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType
public func >>> <Transform>(left: [Transform.Object], right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType
public func <- <Transform>(left: inout [Transform.Object]?, right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType
public func >>> <Transform>(left: [Transform.Object]?, right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType
public func <- <Transform>(left: inout [Swift.String : Transform.Object], right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType
public func >>> <Transform>(left: [Swift.String : Transform.Object], right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType
public func <- <Transform>(left: inout [Swift.String : Transform.Object]?, right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType
public func >>> <Transform>(left: [Swift.String : Transform.Object]?, right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType
public func <- <Transform>(left: inout Transform.Object, right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType, Transform.Object : MIBSFramework.BaseMappable
public func >>> <Transform>(left: Transform.Object, right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType, Transform.Object : MIBSFramework.BaseMappable
public func <- <Transform>(left: inout Transform.Object?, right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType, Transform.Object : MIBSFramework.BaseMappable
public func >>> <Transform>(left: Transform.Object?, right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType, Transform.Object : MIBSFramework.BaseMappable
public func <- <Transform>(left: inout Swift.Dictionary<Swift.String, Transform.Object>, right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType, Transform.Object : MIBSFramework.BaseMappable
public func >>> <Transform>(left: Swift.Dictionary<Swift.String, Transform.Object>, right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType, Transform.Object : MIBSFramework.BaseMappable
public func <- <Transform>(left: inout Swift.Dictionary<Swift.String, Transform.Object>?, right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType, Transform.Object : MIBSFramework.BaseMappable
public func >>> <Transform>(left: Swift.Dictionary<Swift.String, Transform.Object>?, right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType, Transform.Object : MIBSFramework.BaseMappable
public func <- <Transform>(left: inout Swift.Dictionary<Swift.String, [Transform.Object]>, right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType, Transform.Object : MIBSFramework.BaseMappable
public func >>> <Transform>(left: Swift.Dictionary<Swift.String, [Transform.Object]>, right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType, Transform.Object : MIBSFramework.BaseMappable
public func <- <Transform>(left: inout Swift.Dictionary<Swift.String, [Transform.Object]>?, right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType, Transform.Object : MIBSFramework.BaseMappable
public func >>> <Transform>(left: Swift.Dictionary<Swift.String, [Transform.Object]>?, right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType, Transform.Object : MIBSFramework.BaseMappable
public func <- <Transform>(left: inout Swift.Array<Transform.Object>, right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType, Transform.Object : MIBSFramework.BaseMappable
public func >>> <Transform>(left: Swift.Array<Transform.Object>, right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType, Transform.Object : MIBSFramework.BaseMappable
public func <- <Transform>(left: inout Swift.Array<Transform.Object>?, right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType, Transform.Object : MIBSFramework.BaseMappable
public func >>> <Transform>(left: Swift.Array<Transform.Object>?, right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType, Transform.Object : MIBSFramework.BaseMappable
public func <- <Transform>(left: inout [[Transform.Object]], right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType
public func >>> <Transform>(left: [[Transform.Object]], right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType
public func <- <Transform>(left: inout [[Transform.Object]]?, right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType
public func >>> <Transform>(left: [[Transform.Object]]?, right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType
public func <- <Transform>(left: inout Swift.Set<Transform.Object>, right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType, Transform.Object : MIBSFramework.BaseMappable, Transform.Object : Swift.Hashable
public func >>> <Transform>(left: Swift.Set<Transform.Object>, right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType, Transform.Object : MIBSFramework.BaseMappable, Transform.Object : Swift.Hashable
public func <- <Transform>(left: inout Swift.Set<Transform.Object>?, right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType, Transform.Object : MIBSFramework.BaseMappable, Transform.Object : Swift.Hashable
public func >>> <Transform>(left: Swift.Set<Transform.Object>?, right: (MIBSFramework.Map, Transform)) where Transform : MIBSFramework.TransformType, Transform.Object : MIBSFramework.BaseMappable, Transform.Object : Swift.Hashable
public typealias Parameters = [Swift.String : Any]
public protocol ParameterEncoding {
  func encode(_ urlRequest: MIBSFramework.URLRequestConvertible, with parameters: MIBSFramework.Parameters?) throws -> Foundation.URLRequest
}
public struct URLEncoding : MIBSFramework.ParameterEncoding {
  public enum Destination {
    case methodDependent
    case queryString
    case httpBody
    public static func == (a: MIBSFramework.URLEncoding.Destination, b: MIBSFramework.URLEncoding.Destination) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum ArrayEncoding {
    case brackets
    case noBrackets
    case indexInBrackets
    public static func == (a: MIBSFramework.URLEncoding.ArrayEncoding, b: MIBSFramework.URLEncoding.ArrayEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum BoolEncoding {
    case numeric
    case literal
    public static func == (a: MIBSFramework.URLEncoding.BoolEncoding, b: MIBSFramework.URLEncoding.BoolEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var `default`: MIBSFramework.URLEncoding {
    get
  }
  public static var queryString: MIBSFramework.URLEncoding {
    get
  }
  public static var httpBody: MIBSFramework.URLEncoding {
    get
  }
  public let destination: MIBSFramework.URLEncoding.Destination
  public let arrayEncoding: MIBSFramework.URLEncoding.ArrayEncoding
  public let boolEncoding: MIBSFramework.URLEncoding.BoolEncoding
  public init(destination: MIBSFramework.URLEncoding.Destination = .methodDependent, arrayEncoding: MIBSFramework.URLEncoding.ArrayEncoding = .brackets, boolEncoding: MIBSFramework.URLEncoding.BoolEncoding = .numeric)
  public func encode(_ urlRequest: MIBSFramework.URLRequestConvertible, with parameters: MIBSFramework.Parameters?) throws -> Foundation.URLRequest
  public func queryComponents(fromKey key: Swift.String, value: Any) -> [(Swift.String, Swift.String)]
  public func escape(_ string: Swift.String) -> Swift.String
}
public struct JSONEncoding : MIBSFramework.ParameterEncoding {
  public enum Error : Swift.Error {
    case invalidJSONObject
    public static func == (a: MIBSFramework.JSONEncoding.Error, b: MIBSFramework.JSONEncoding.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var `default`: MIBSFramework.JSONEncoding {
    get
  }
  public static var prettyPrinted: MIBSFramework.JSONEncoding {
    get
  }
  public let options: Foundation.JSONSerialization.WritingOptions
  public init(options: Foundation.JSONSerialization.WritingOptions = [])
  public func encode(_ urlRequest: MIBSFramework.URLRequestConvertible, with parameters: MIBSFramework.Parameters?) throws -> Foundation.URLRequest
  public func encode(_ urlRequest: MIBSFramework.URLRequestConvertible, withJSONObject jsonObject: Any? = nil) throws -> Foundation.URLRequest
}
extension MIBSFramework.JSONEncoding.Error {
  public var localizedDescription: Swift.String {
    get
  }
}
public typealias LottieCompletionBlock = (Swift.Bool) -> Swift.Void
open class DefaultTextFormatter : MIBSFramework.TextFormatter, MIBSFramework.TextUnformatter {
  final public let textPattern: Swift.String
  final public let patternSymbol: Swift.Character
  public init(textPattern: Swift.String, patternSymbol: Swift.Character = Constants.defaultPatternSymbol)
  open func format(_ unformattedText: Swift.String?) -> Swift.String?
  open func unformat(_ formatted: Swift.String?) -> Swift.String?
  public struct Constants {
    public static let defaultPatternSymbol: Swift.Character
  }
  @objc deinit
}
@objc public protocol BarcodeDetectionViewControllerDelegate {
  @objc func barcodeDetectionViewController(_ viewController: MIBSFramework.BarcodeDetectionViewController, didDetectBarcodes barcodes: [Vision.VNBarcodeObservation])
  @objc optional func barcodeDetectionViewControllerDidCancel(_ viewController: MIBSFramework.BarcodeDetectionViewController)
}
final public class ImageResponseSerializer : MIBSFramework.ResponseSerializer {
  public static var deviceScreenScale: CoreFoundation.CGFloat {
    get
  }
  final public let imageScale: CoreFoundation.CGFloat
  final public let inflateResponseImage: Swift.Bool
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod>
  public init(imageScale: CoreFoundation.CGFloat = ImageResponseSerializer.deviceScreenScale, inflateResponseImage: Swift.Bool = true, emptyResponseCodes: Swift.Set<Swift.Int> = ImageResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<MIBSFramework.HTTPMethod> = ImageResponseSerializer.defaultEmptyRequestMethods)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> MIBSFramework.Image
  final public func serializeImage(from data: Foundation.Data) throws -> MIBSFramework.Image
  final public class func addAcceptableImageContentTypes(_ contentTypes: Swift.Set<Swift.String>)
  final public func validateContentType(for request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?) throws
  public typealias SerializedObject = MIBSFramework.Image
  @objc deinit
}
extension MIBSFramework.DataRequest {
  public class var imageScale: CoreFoundation.CGFloat {
    get
  }
}
extension MIBSFramework.DataRequest {
  @discardableResult
  public func responseImage(imageScale: CoreFoundation.CGFloat = DataRequest.imageScale, inflateResponseImage: Swift.Bool = true, queue: Dispatch.DispatchQueue = .main, completionHandler: @escaping (MIBSFramework.AFDataResponse<MIBSFramework.Image>) -> Swift.Void) -> Self
}
@_inheritsConvenienceInitializers @objc public class CardDetectionSettings : MIBSFramework.BaseCardDetectionSettings, MIBSFramework.TorchSettings {
  @objc public var torchLevel: Swift.Float
  @objc override public init(width: CoreFoundation.CGFloat, height: CoreFoundation.CGFloat)
  @objc deinit
}
@_inheritsConvenienceInitializers @objc public class BaseCardDetectionSettings : ObjectiveC.NSObject {
  @objc public enum Orientation : Swift.Int {
    case landscape
    case portrait
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc public var size: CoreFoundation.CGSize
  @objc public var orientation: MIBSFramework.BaseCardDetectionSettings.Orientation {
    @objc get
    @objc set
  }
  @objc public var imagePoolSize: Swift.Int
  @objc public init(width: CoreFoundation.CGFloat, height: CoreFoundation.CGFloat)
  @objc convenience override dynamic public init()
  @objc deinit
}
public protocol TextNumberFormatter {
  func format(_ number: Foundation.NSNumber) -> Swift.String?
}
extension MIBSFramework.PopoverType : Swift.Equatable {}
extension MIBSFramework.PopoverType : Swift.Hashable {}
extension MIBSFramework.PopoverType : Swift.RawRepresentable {}
extension MIBSFramework.SwiftyJSONError : Swift.Equatable {}
extension MIBSFramework.SwiftyJSONError : Swift.Hashable {}
extension MIBSFramework.SwiftyJSONError : Swift.RawRepresentable {}
extension MIBSFramework.`Type` : Swift.Equatable {}
extension MIBSFramework.`Type` : Swift.Hashable {}
extension MIBSFramework.`Type` : Swift.RawRepresentable {}
extension MIBSFramework.writingOptionsKeys : Swift.Equatable {}
extension MIBSFramework.writingOptionsKeys : Swift.Hashable {}
extension MIBSFramework.LottieBackgroundBehavior : Swift.Equatable {}
extension MIBSFramework.LottieBackgroundBehavior : Swift.Hashable {}
extension MIBSFramework.ToastPosition : Swift.Equatable {}
extension MIBSFramework.ToastPosition : Swift.Hashable {}
extension MIBSFramework.Request.State : Swift.Equatable {}
extension MIBSFramework.Request.State : Swift.Hashable {}
extension MIBSFramework.ImageDownloader.DownloadPrioritization : Swift.Equatable {}
extension MIBSFramework.ImageDownloader.DownloadPrioritization : Swift.Hashable {}
extension MIBSFramework.BlendMode : Swift.Equatable {}
extension MIBSFramework.BlendMode : Swift.Hashable {}
extension MIBSFramework.BlendMode : Swift.RawRepresentable {}
extension MIBSFramework.FloatValueProvider : MIBSFramework.AnyValueProvider {}
extension MIBSFramework.BarcodeDetectionSettingsError : Swift.Equatable {}
extension MIBSFramework.BarcodeDetectionSettingsError : Swift.Hashable {}
extension MIBSFramework.BarcodeDetectionSettingsError : Swift.RawRepresentable {}
extension MIBSFramework.ColorValueProvider : MIBSFramework.AnyValueProvider {}
extension MIBSFramework.GradientValueProvider : MIBSFramework.AnyValueProvider {}
extension MIBSFramework.SizeValueProvider : MIBSFramework.AnyValueProvider {}
extension MIBSFramework.MappingType : Swift.Equatable {}
extension MIBSFramework.MappingType : Swift.Hashable {}
extension MIBSFramework.AnimatedSwitch.CancelBehavior : Swift.Equatable {}
extension MIBSFramework.AnimatedSwitch.CancelBehavior : Swift.Hashable {}
extension MIBSFramework.URLEncodedFormParameterEncoder.Destination : Swift.Equatable {}
extension MIBSFramework.URLEncodedFormParameterEncoder.Destination : Swift.Hashable {}
extension UIKit.UIImage.DataUnits : Swift.Equatable {}
extension UIKit.UIImage.DataUnits : Swift.Hashable {}
extension UIKit.UIImage.DataUnits : Swift.RawRepresentable {}
extension MIBSFramework.CoordinateSpace : Swift.Equatable {}
extension MIBSFramework.CoordinateSpace : Swift.Hashable {}
extension MIBSFramework.CoordinateSpace : Swift.RawRepresentable {}
extension MIBSFramework.AuthenticationError : Swift.Equatable {}
extension MIBSFramework.AuthenticationError : Swift.Hashable {}
extension MIBSFramework.URLEncodedFormEncoder.ArrayEncoding : Swift.Equatable {}
extension MIBSFramework.URLEncodedFormEncoder.ArrayEncoding : Swift.Hashable {}
extension MIBSFramework.URLEncodedFormEncoder.BoolEncoding : Swift.Equatable {}
extension MIBSFramework.URLEncodedFormEncoder.BoolEncoding : Swift.Hashable {}
extension MIBSFramework.URLEncodedFormEncoder.SpaceEncoding : Swift.Equatable {}
extension MIBSFramework.URLEncodedFormEncoder.SpaceEncoding : Swift.Hashable {}
extension MIBSFramework.DateTransform.Unit : Swift.Equatable {}
extension MIBSFramework.DateTransform.Unit : Swift.Hashable {}
extension MIBSFramework.DateTransform.Unit : Swift.RawRepresentable {}
@available(iOSApplicationExtension, unavailable)
extension MIBSFramework.IQAutoToolbarManageBehaviour : Swift.Equatable {}
@available(iOSApplicationExtension, unavailable)
extension MIBSFramework.IQAutoToolbarManageBehaviour : Swift.Hashable {}
@available(iOSApplicationExtension, unavailable)
extension MIBSFramework.IQAutoToolbarManageBehaviour : Swift.RawRepresentable {}
@available(iOSApplicationExtension, unavailable)
extension MIBSFramework.IQPreviousNextDisplayMode : Swift.Equatable {}
@available(iOSApplicationExtension, unavailable)
extension MIBSFramework.IQPreviousNextDisplayMode : Swift.Hashable {}
@available(iOSApplicationExtension, unavailable)
extension MIBSFramework.IQPreviousNextDisplayMode : Swift.RawRepresentable {}
@available(iOSApplicationExtension, unavailable)
extension MIBSFramework.IQEnableMode : Swift.Equatable {}
@available(iOSApplicationExtension, unavailable)
extension MIBSFramework.IQEnableMode : Swift.Hashable {}
@available(iOSApplicationExtension, unavailable)
extension MIBSFramework.IQEnableMode : Swift.RawRepresentable {}
extension MIBSFramework.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType : Swift.Equatable {}
extension MIBSFramework.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType : Swift.Hashable {}
@available(*, unavailable, renamed: "Connection")
extension MIBSFramework.Reachability.NetworkStatus : Swift.Equatable {}
@available(*, unavailable, renamed: "Connection")
extension MIBSFramework.Reachability.NetworkStatus : Swift.Hashable {}
extension MIBSFramework.Reachability.Connection : Swift.Equatable {}
extension MIBSFramework.Reachability.Connection : Swift.Hashable {}
extension MIBSFramework.LayerType : Swift.Equatable {}
extension MIBSFramework.LayerType : Swift.Hashable {}
extension MIBSFramework.LayerType : Swift.RawRepresentable {}
extension MIBSFramework.MatteType : Swift.Equatable {}
extension MIBSFramework.MatteType : Swift.Hashable {}
extension MIBSFramework.MatteType : Swift.RawRepresentable {}
extension MIBSFramework.PointValueProvider : MIBSFramework.AnyValueProvider {}
extension MIBSFramework.URLEncoding.Destination : Swift.Equatable {}
extension MIBSFramework.URLEncoding.Destination : Swift.Hashable {}
extension MIBSFramework.URLEncoding.ArrayEncoding : Swift.Equatable {}
extension MIBSFramework.URLEncoding.ArrayEncoding : Swift.Hashable {}
extension MIBSFramework.URLEncoding.BoolEncoding : Swift.Equatable {}
extension MIBSFramework.URLEncoding.BoolEncoding : Swift.Hashable {}
extension MIBSFramework.JSONEncoding.Error : Swift.Equatable {}
extension MIBSFramework.JSONEncoding.Error : Swift.Hashable {}
extension MIBSFramework.BaseCardDetectionSettings.Orientation : Swift.Equatable {}
extension MIBSFramework.BaseCardDetectionSettings.Orientation : Swift.Hashable {}
extension MIBSFramework.BaseCardDetectionSettings.Orientation : Swift.RawRepresentable {}
